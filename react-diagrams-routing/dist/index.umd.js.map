{"version":3,"file":"index.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChQA;AAIA;;;;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AAOA;AAEA;;;;AAIA;AACA;AAeA;AACA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAaA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAcA;AACA;AAdA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA0IA;;;AAGA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AA0GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvPA;;;;;;;;;;;;;;;;;;ACpCA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AAEA;AAGA;AAeA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAUA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAZA;;;;;;;;;;;;;;;;;;ACTA;AACA;AAIA;AAIA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClEA;AACA;AAEA;AACA;AAkBA;AAgBA;AACA;AAwIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/IA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAUA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;;AA3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9BA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA","sources":["webpack://projectstorm/react-diagrams-routing/webpack/universalModuleDefinition","webpack://projectstorm/react-diagrams-routing/./src/dagre/DagreEngine.ts","webpack://projectstorm/react-diagrams-routing/./src/engine/PathFinding.ts","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/geometry\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-canvas-core\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-diagrams-core\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-diagrams-defaults\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"dagre\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/cloneDeep\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/concat\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/defer\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/every\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/findIndex\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/first\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/flatMap\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/forEach\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/get\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/last\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/map\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/maxBy\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/minBy\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/range\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/reduce\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/sortBy\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/values\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"pathfinding\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"paths-js/path\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"react\"","webpack://projectstorm/react-diagrams-routing/webpack/bootstrap","webpack://projectstorm/react-diagrams-routing/webpack/runtime/compat get default export","webpack://projectstorm/react-diagrams-routing/webpack/runtime/define property getters","webpack://projectstorm/react-diagrams-routing/webpack/runtime/hasOwnProperty shorthand","webpack://projectstorm/react-diagrams-routing/webpack/runtime/make namespace object","webpack://projectstorm/react-diagrams-routing/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"projectstorm/react-diagrams-routing\"] = factory();\n\telse\n\t\troot[\"projectstorm/react-diagrams-routing\"] = factory();\n})(self, () => {\nreturn ","import { DiagramModel, PointModel } from '@projectstorm/react-diagrams-core';\r\nimport * as dagre from 'dagre';\r\nimport { GraphLabel } from 'dagre';\r\nimport _every from 'lodash/every';\r\nimport _findIndex from 'lodash/findIndex';\r\nimport _forEach from 'lodash/forEach';\r\nimport _map from 'lodash/map';\r\nimport _range from 'lodash/range';\r\nimport _sortBy from 'lodash/sortBy';\r\nimport { Point } from '@projectstorm/geometry';\r\n\r\nexport interface DagreEngineOptions {\r\n\tgraph?: GraphLabel;\r\n\t/**\r\n\t * Will also re-layout links\r\n\t */\r\n\tincludeLinks?: boolean;\r\n\tnodeMargin?: number;\r\n}\r\n\r\nexport class DagreEngine {\r\n\toptions: DagreEngineOptions;\r\n\r\n\tconstructor(options: DagreEngineOptions = {}) {\r\n\t\tthis.options = options;\r\n\t}\r\n\r\n\tredistribute(model: DiagramModel) {\r\n\t\t// Create a new directed graph\r\n\t\tvar g = new dagre.graphlib.Graph({\r\n\t\t\tmultigraph: true,\r\n\t\t\tcompound: true\r\n\t\t});\r\n\t\tg.setGraph(this.options.graph || {});\r\n\t\tg.setDefaultEdgeLabel(function () {\r\n\t\t\treturn {};\r\n\t\t});\r\n\r\n\t\t// set nodes\r\n\t\t_forEach(model.getNodes(), (node) => {\r\n\t\t\tg.setNode(node.getID(), { width: node.width, height: node.height });\r\n\t\t});\r\n\r\n\t\t_forEach(model.getLinks(), (link) => {\r\n\t\t\t// set edges\r\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\r\n\t\t\t\tg.setEdge({\r\n\t\t\t\t\tv: link.getSourcePort().getNode().getID(),\r\n\t\t\t\t\tw: link.getTargetPort().getNode().getID(),\r\n\t\t\t\t\tname: link.getID()\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// layout the graph\r\n\t\tdagre.layout(g);\r\n\r\n\t\tg.nodes().forEach((v) => {\r\n\t\t\tconst node = g.node(v);\r\n\t\t\tmodel.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\r\n\t\t});\r\n\r\n\t\t// also include links?\r\n\t\tif (this.options.includeLinks) {\r\n\t\t\tg.edges().forEach((e) => {\r\n\t\t\t\tconst edge = g.edge(e);\r\n\t\t\t\tconst link = model.getLink(e.name);\r\n\r\n\t\t\t\tconst points = [link.getFirstPoint()];\r\n\t\t\t\tfor (let i = 1; i < edge.points.length - 1; i++) {\r\n\t\t\t\t\tpoints.push(new PointModel({ link: link, position: new Point(edge.points[i].x, edge.points[i].y) }));\r\n\t\t\t\t}\r\n\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * TODO cleanup this method into smaller methods\r\n\t */\r\n\tpublic refreshLinks(diagram: DiagramModel) {\r\n\t\tconst { nodeMargin } = this.options;\r\n\t\tconst nodes = diagram.getNodes();\r\n\t\tconst links = diagram.getLinks();\r\n\t\tlet maxChunkRowIndex = -1;\r\n\t\t// build the chunk matrix\r\n\t\tconst chunks: { [id: number]: { [id: number]: boolean } } = {}; // true: occupied, false: blank\r\n\t\tconst NodeXColumnIndexDictionary: { [id: number]: number } = {};\r\n\t\tlet verticalLines: number[] = [];\r\n\t\t_forEach(nodes, (node) => {\r\n\t\t\t// find vertical lines. vertical lines go through maximum number of nodes located under each other.\r\n\t\t\tconst nodeColumnCenter = node.getX() + node.width / 2;\r\n\t\t\tif (\r\n\t\t\t\t_every(verticalLines, (vLine) => {\r\n\t\t\t\t\treturn Math.abs(nodeColumnCenter - vLine) > nodeMargin;\r\n\t\t\t\t})\r\n\t\t\t) {\r\n\t\t\t\tverticalLines.push(nodeColumnCenter);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// sort chunk columns\r\n\t\tverticalLines = verticalLines.sort((a, b) => a - b);\r\n\t\t_forEach(verticalLines, (line, index) => {\r\n\t\t\tchunks[index] = {};\r\n\t\t\tchunks[index + 0.5] = {};\r\n\t\t});\r\n\r\n\t\t// set occupied chunks\r\n\t\t_forEach(nodes, (node) => {\r\n\t\t\tconst nodeColumnCenter = node.getX() + node.width / 2;\r\n\t\t\tconst startChunkIndex = Math.floor(node.getY() / nodeMargin);\r\n\t\t\tconst endChunkIndex = Math.floor((node.getY() + node.height) / nodeMargin);\r\n\t\t\t// find max ChunkRowIndex\r\n\t\t\tif (endChunkIndex > maxChunkRowIndex) maxChunkRowIndex = endChunkIndex;\r\n\t\t\tconst nodeColumnIndex = _findIndex(verticalLines, (vLine) => {\r\n\t\t\t\treturn Math.abs(nodeColumnCenter - vLine) <= nodeMargin;\r\n\t\t\t});\r\n\t\t\t_forEach(_range(startChunkIndex, endChunkIndex + 1), (chunkIndex) => {\r\n\t\t\t\tchunks[nodeColumnIndex][chunkIndex] = true;\r\n\t\t\t});\r\n\t\t\tNodeXColumnIndexDictionary[node.getX()] = nodeColumnIndex;\r\n\t\t});\r\n\r\n\t\t// sort links based on their distances\r\n\t\tconst edges = _map(links, (link) => {\r\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\r\n\t\t\t\tconst source = link.getSourcePort().getNode();\r\n\t\t\t\tconst target = link.getTargetPort().getNode();\r\n\t\t\t\tconst sourceIndex = NodeXColumnIndexDictionary[source.getX()];\r\n\t\t\t\tconst targetIndex = NodeXColumnIndexDictionary[target.getX()];\r\n\r\n\t\t\t\treturn sourceIndex > targetIndex\r\n\t\t\t\t\t? {\r\n\t\t\t\t\t\t\tlink,\r\n\t\t\t\t\t\t\tsourceIndex,\r\n\t\t\t\t\t\t\tsourceY: source.getY() + source.height / 2,\r\n\t\t\t\t\t\t\tsource,\r\n\t\t\t\t\t\t\ttargetIndex,\r\n\t\t\t\t\t\t\ttargetY: target.getY() + source.height / 2,\r\n\t\t\t\t\t\t\ttarget\r\n\t\t\t\t\t  }\r\n\t\t\t\t\t: {\r\n\t\t\t\t\t\t\tlink,\r\n\t\t\t\t\t\t\tsourceIndex: targetIndex,\r\n\t\t\t\t\t\t\tsourceY: target.getY() + target.height / 2,\r\n\t\t\t\t\t\t\tsource: target,\r\n\t\t\t\t\t\t\ttargetIndex: sourceIndex,\r\n\t\t\t\t\t\t\ttargetY: source.getY() + source.height / 2,\r\n\t\t\t\t\t\t\ttarget: source\r\n\t\t\t\t\t  };\r\n\t\t\t}\r\n\t\t});\r\n\t\tconst sortedEdges = _sortBy(edges, (link) => {\r\n\t\t\treturn Math.abs(link.targetIndex - link.sourceIndex);\r\n\t\t});\r\n\r\n\t\t// set link points\r\n\t\tif (this.options.includeLinks) {\r\n\t\t\t_forEach(sortedEdges, (edge) => {\r\n\t\t\t\tconst link = diagram.getLink(edge.link.getID());\r\n\t\t\t\t// re-draw\r\n\t\t\t\tif (Math.abs(edge.sourceIndex - edge.targetIndex) > 1) {\r\n\t\t\t\t\t// get the length of link in column\r\n\t\t\t\t\tconst columns = _range(edge.sourceIndex - 1, edge.targetIndex);\r\n\r\n\t\t\t\t\tconst chunkIndex = Math.floor(edge.sourceY / nodeMargin);\r\n\t\t\t\t\tconst targetChunkIndex = Math.floor(edge.targetY / nodeMargin);\r\n\r\n\t\t\t\t\t// check upper paths\r\n\t\t\t\t\tlet northCost = 1;\r\n\t\t\t\t\tlet aboveRowIndex = chunkIndex;\r\n\t\t\t\t\tfor (; aboveRowIndex >= 0; aboveRowIndex--, northCost++) {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t_every(columns, (columnIndex) => {\r\n\t\t\t\t\t\t\t\treturn !(\r\n\t\t\t\t\t\t\t\t\tchunks[columnIndex][aboveRowIndex] ||\r\n\t\t\t\t\t\t\t\t\tchunks[columnIndex + 0.5][aboveRowIndex] ||\r\n\t\t\t\t\t\t\t\t\tchunks[columnIndex - 0.5][aboveRowIndex]\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// check lower paths\r\n\t\t\t\t\tlet southCost = 0;\r\n\t\t\t\t\tlet belowRowIndex = chunkIndex;\r\n\t\t\t\t\tfor (; belowRowIndex <= maxChunkRowIndex; belowRowIndex++, southCost++) {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t_every(columns, (columnIndex) => {\r\n\t\t\t\t\t\t\t\treturn !(\r\n\t\t\t\t\t\t\t\t\tchunks[columnIndex][belowRowIndex] ||\r\n\t\t\t\t\t\t\t\t\tchunks[columnIndex + 0.5][belowRowIndex] ||\r\n\t\t\t\t\t\t\t\t\tchunks[columnIndex - 0.5][belowRowIndex]\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// pick the cheapest path\r\n\t\t\t\t\tconst pathRowIndex =\r\n\t\t\t\t\t\tsouthCost + (belowRowIndex - targetChunkIndex) < northCost + (targetChunkIndex - aboveRowIndex)\r\n\t\t\t\t\t\t\t? belowRowIndex + 1\r\n\t\t\t\t\t\t\t: aboveRowIndex - 1;\r\n\r\n\t\t\t\t\t// Finally update the link points\r\n\t\t\t\t\tconst points = [link.getFirstPoint()];\r\n\t\t\t\t\tpoints.push(\r\n\t\t\t\t\t\tnew PointModel({\r\n\t\t\t\t\t\t\tlink: link,\r\n\t\t\t\t\t\t\tposition: new Point(\r\n\t\t\t\t\t\t\t\t(verticalLines[columns[0]] + verticalLines[columns[0] + 1]) / 2,\r\n\t\t\t\t\t\t\t\t(pathRowIndex + 0.5) * nodeMargin\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t_forEach(columns, (column) => {\r\n\t\t\t\t\t\tpoints.push(\r\n\t\t\t\t\t\t\tnew PointModel({\r\n\t\t\t\t\t\t\t\tlink: link,\r\n\t\t\t\t\t\t\t\tposition: new Point(verticalLines[column], (pathRowIndex + 0.5) * nodeMargin)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tpoints.push(\r\n\t\t\t\t\t\t\tnew PointModel({\r\n\t\t\t\t\t\t\t\tlink: link,\r\n\t\t\t\t\t\t\t\tposition: new Point(\r\n\t\t\t\t\t\t\t\t\t(verticalLines[column] + verticalLines[column - 1]) / 2,\r\n\t\t\t\t\t\t\t\t\t(pathRowIndex + 0.5) * nodeMargin\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tchunks[column][pathRowIndex] = true;\r\n\t\t\t\t\t\tchunks[column][pathRowIndex + 1] = true;\r\n\t\t\t\t\t\tchunks[column + 0.5][pathRowIndex] = true;\r\n\t\t\t\t\t\tchunks[column + 0.5][pathRowIndex + 1] = true;\r\n\t\t\t\t\t});\r\n\t\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// refresh\r\n\t\t\t\t\tlink.setPoints([link.getFirstPoint(), link.getLastPoint()]);\r\n\t\t\t\t\tconst columnIndex = (edge.sourceIndex + edge.targetIndex) / 2;\r\n\t\t\t\t\tif (!chunks[columnIndex]) {\r\n\t\t\t\t\t\tchunks[columnIndex] = {};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst rowIndex = Math.floor((edge.sourceY + edge.targetY) / 2 / nodeMargin);\r\n\t\t\t\t\tchunks[columnIndex][rowIndex] = true;\r\n\t\t\t\t\tchunks[columnIndex][rowIndex + 1] = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n","import * as PF from 'pathfinding';\r\nimport { PathFindingLinkFactory } from '../link/PathFindingLinkFactory';\r\nimport { PointModel } from '@projectstorm/react-diagrams-core';\r\n\r\n/*\r\nit can be very expensive to calculate routes when every single pixel on the canvas\r\nis individually represented. Using the factor below, we combine values in order\r\nto achieve the best trade-off between accuracy and performance.\r\n*/\r\n\r\nconst pathFinderInstance = new PF.JumpPointFinder({\r\n\theuristic: PF.Heuristic.manhattan,\r\n\tdiagonalMovement: PF.DiagonalMovement.Never\r\n});\r\n\r\nexport class PathFinding {\r\n\tinstance: any;\r\n\tfactory: PathFindingLinkFactory;\r\n\r\n\tconstructor(factory: PathFindingLinkFactory) {\r\n\t\tthis.instance = pathFinderInstance;\r\n\t\tthis.factory = factory;\r\n\t}\r\n\r\n\t/**\r\n\t * Taking as argument a fully unblocked walking matrix, this method\r\n\t * finds a direct path from point A to B.\r\n\t */\r\n\tcalculateDirectPath(from: PointModel, to: PointModel): number[][] {\r\n\t\tconst matrix = this.factory.getCanvasMatrix();\r\n\t\tconst grid = new PF.Grid(matrix);\r\n\r\n\t\treturn pathFinderInstance.findPath(\r\n\t\t\tthis.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)),\r\n\t\t\tthis.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)),\r\n\t\t\tthis.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)),\r\n\t\t\tthis.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)),\r\n\t\t\tgrid\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Using @link{#calculateDirectPath}'s result as input, we here\r\n\t * determine the first walkable point found in the matrix that includes\r\n\t * blocked paths.\r\n\t */\r\n\tcalculateLinkStartEndCoords(\r\n\t\tmatrix: number[][],\r\n\t\tpath: number[][]\r\n\t): {\r\n\t\tstart: {\r\n\t\t\tx: number;\r\n\t\t\ty: number;\r\n\t\t};\r\n\t\tend: {\r\n\t\t\tx: number;\r\n\t\t\ty: number;\r\n\t\t};\r\n\t\tpathToStart: number[][];\r\n\t\tpathToEnd: number[][];\r\n\t} {\r\n\t\tconst startIndex = path.findIndex((point) => {\r\n\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\r\n\t\t\telse return false;\r\n\t\t});\r\n\t\tconst endIndex =\r\n\t\t\tpath.length -\r\n\t\t\t1 -\r\n\t\t\tpath\r\n\t\t\t\t.slice()\r\n\t\t\t\t.reverse()\r\n\t\t\t\t.findIndex((point) => {\r\n\t\t\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\r\n\t\t\t\t\telse return false;\r\n\t\t\t\t});\r\n\r\n\t\t// are we trying to create a path exclusively through blocked areas?\r\n\t\t// if so, let's fallback to the linear routing\r\n\t\tif (startIndex === -1 || endIndex === -1) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tconst pathToStart = path.slice(0, startIndex);\r\n\t\tconst pathToEnd = path.slice(endIndex);\r\n\r\n\t\treturn {\r\n\t\t\tstart: {\r\n\t\t\t\tx: path[startIndex][0],\r\n\t\t\t\ty: path[startIndex][1]\r\n\t\t\t},\r\n\t\t\tend: {\r\n\t\t\t\tx: path[endIndex][0],\r\n\t\t\t\ty: path[endIndex][1]\r\n\t\t\t},\r\n\t\t\tpathToStart,\r\n\t\t\tpathToEnd\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Puts everything together: merges the paths from/to the centre of the ports,\r\n\t * with the path calculated around other elements.\r\n\t */\r\n\tcalculateDynamicPath(\r\n\t\troutingMatrix: number[][],\r\n\t\tstart: {\r\n\t\t\tx: number;\r\n\t\t\ty: number;\r\n\t\t},\r\n\t\tend: {\r\n\t\t\tx: number;\r\n\t\t\ty: number;\r\n\t\t},\r\n\t\tpathToStart: number[][],\r\n\t\tpathToEnd: number[][]\r\n\t) {\r\n\t\t// generate the path based on the matrix with obstacles\r\n\t\tconst grid = new PF.Grid(routingMatrix);\r\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\r\n\r\n\t\t// aggregate everything to have the calculated path ready for rendering\r\n\t\tconst pathCoords = pathToStart\r\n\t\t\t.concat(dynamicPath, pathToEnd)\r\n\t\t\t.map((coords) => [\r\n\t\t\t\tthis.factory.translateRoutingX(coords[0], true),\r\n\t\t\t\tthis.factory.translateRoutingY(coords[1], true)\r\n\t\t\t]);\r\n\t\treturn PF.Util.compressPath(pathCoords);\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\r\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\r\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\r\nimport _cloneDeep from 'lodash/cloneDeep';\r\nimport _concat from 'lodash/concat';\r\nimport _defer from 'lodash/defer';\r\nimport _flatMap from 'lodash/flatMap';\r\nimport _get from 'lodash/get';\r\nimport _minBy from 'lodash/minBy';\r\nimport _maxBy from 'lodash/maxBy';\r\nimport _range from 'lodash/range';\r\nimport _reduce from 'lodash/reduce';\r\nimport _values from 'lodash/values';\r\nimport * as Path from 'paths-js/path';\r\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\r\nimport {\r\n\tAbstractDisplacementState,\r\n\tAbstractFactory,\r\n\tAction,\r\n\tFactoryBank,\r\n\tInputType,\r\n\tListenerHandle\r\n} from '@projectstorm/react-canvas-core';\r\n\r\nexport class PathFindingLinkFactory extends DefaultLinkFactory<PathFindingLinkModel> {\r\n\tROUTING_SCALING_FACTOR: number = 5;\r\n\r\n\t// calculated only when smart routing is active\r\n\tcanvasMatrix: number[][] = [];\r\n\troutingMatrix: number[][] = [];\r\n\r\n\t// used when at least one element has negative coordinates\r\n\thAdjustmentFactor: number = 0;\r\n\tvAdjustmentFactor: number = 0;\r\n\r\n\tstatic NAME = 'pathfinding';\r\n\tlistener: ListenerHandle;\r\n\r\n\tconstructor() {\r\n\t\tsuper(PathFindingLinkFactory.NAME);\r\n\t}\r\n\r\n\tsetDiagramEngine(engine: DiagramEngine): void {\r\n\t\tsuper.setDiagramEngine(engine);\r\n\r\n\t\t// listen for drag changes\r\n\t\tengine.getStateMachine().registerListener({\r\n\t\t\tstateChanged: (event) => {\r\n\t\t\t\tif (event.newState instanceof AbstractDisplacementState) {\r\n\t\t\t\t\tconst deRegister = engine.getActionEventBus().registerAction(\r\n\t\t\t\t\t\tnew Action<DiagramEngine>({\r\n\t\t\t\t\t\t\ttype: InputType.MOUSE_UP,\r\n\t\t\t\t\t\t\tfire: () => {\r\n\t\t\t\t\t\t\t\tthis.calculateRoutingMatrix();\r\n\t\t\t\t\t\t\t\tengine.repaintCanvas();\r\n\t\t\t\t\t\t\t\tdeRegister();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis.listener = engine.registerListener({\r\n\t\t\tcanvasReady: () => {\r\n\t\t\t\t_defer(() => {\r\n\t\t\t\t\tthis.calculateRoutingMatrix();\r\n\t\t\t\t\tengine.repaintCanvas();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tsetFactoryBank(bank: FactoryBank<AbstractFactory>): void {\r\n\t\tsuper.setFactoryBank(bank);\r\n\t\tif (!bank && this.listener) {\r\n\t\t\tthis.listener.deregister();\r\n\t\t}\r\n\t}\r\n\r\n\tgenerateReactWidget(event): JSX.Element {\r\n\t\treturn <PathFindingLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\r\n\t}\r\n\r\n\tgenerateModel(event): PathFindingLinkModel {\r\n\t\treturn new PathFindingLinkModel();\r\n\t}\r\n\r\n\t/**\r\n\t * A representation of the canvas in the following format:\r\n\t *\r\n\t * +-----------------+\r\n\t * | 0 0 0 0 0 0 0 0 |\r\n\t * | 0 0 0 0 0 0 0 0 |\r\n\t * | 0 0 0 0 0 0 0 0 |\r\n\t * | 0 0 0 0 0 0 0 0 |\r\n\t * | 0 0 0 0 0 0 0 0 |\r\n\t * +-----------------+\r\n\t *\r\n\t * In which all walkable points are marked by zeros.\r\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\r\n\t */\r\n\tgetCanvasMatrix(): number[][] {\r\n\t\tif (this.canvasMatrix.length === 0) {\r\n\t\t\tthis.calculateCanvasMatrix();\r\n\t\t}\r\n\r\n\t\treturn this.canvasMatrix;\r\n\t}\r\n\tcalculateCanvasMatrix() {\r\n\t\tconst {\r\n\t\t\twidth: canvasWidth,\r\n\t\t\thAdjustmentFactor,\r\n\t\t\theight: canvasHeight,\r\n\t\t\tvAdjustmentFactor\r\n\t\t} = this.calculateMatrixDimensions();\r\n\r\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\r\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\r\n\r\n\t\tconst matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\r\n\t\tconst matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\r\n\r\n\t\tthis.canvasMatrix = _range(0, matrixHeight).map(() => {\r\n\t\t\treturn new Array(matrixWidth).fill(0);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * A representation of the canvas in the following format:\r\n\t *\r\n\t * +-----------------+\r\n\t * | 0 0 1 1 0 0 0 0 |\r\n\t * | 0 0 1 1 0 0 1 1 |\r\n\t * | 0 0 0 0 0 0 1 1 |\r\n\t * | 1 1 0 0 0 0 0 0 |\r\n\t * | 1 1 0 0 0 0 0 0 |\r\n\t * +-----------------+\r\n\t *\r\n\t * In which all points blocked by a node (and its ports) are\r\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\r\n\t */\r\n\tgetRoutingMatrix(): number[][] {\r\n\t\tif (this.routingMatrix.length === 0) {\r\n\t\t\tthis.calculateRoutingMatrix();\r\n\t\t}\r\n\r\n\t\treturn this.routingMatrix;\r\n\t}\r\n\tcalculateRoutingMatrix(): void {\r\n\t\tconst matrix = _cloneDeep(this.getCanvasMatrix());\r\n\r\n\t\t// nodes need to be marked as blocked points\r\n\t\tthis.markNodes(matrix);\r\n\t\t// same thing for ports\r\n\t\tthis.markPorts(matrix);\r\n\r\n\t\tthis.routingMatrix = matrix;\r\n\t}\r\n\r\n\t/**\r\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\r\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\r\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\r\n\t */\r\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\r\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\r\n\t}\r\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\r\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\r\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\r\n\t */\r\n\tcalculateMatrixDimensions = (): {\r\n\t\twidth: number;\r\n\t\thAdjustmentFactor: number;\r\n\t\theight: number;\r\n\t\tvAdjustmentFactor: number;\r\n\t} => {\r\n\t\tconst allNodesCoords = _values(this.engine.getModel().getNodes()).map((item) => ({\r\n\t\t\tx: item.getX(),\r\n\t\t\twidth: item.width,\r\n\t\t\ty: item.getY(),\r\n\t\t\theight: item.height\r\n\t\t}));\r\n\r\n\t\tconst allLinks = _values(this.engine.getModel().getLinks());\r\n\t\tconst allPortsCoords = _flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\r\n\t\t\t.filter((port) => port !== null)\r\n\t\t\t.map((item) => ({\r\n\t\t\t\tx: item.getX(),\r\n\t\t\t\twidth: item.width,\r\n\t\t\t\ty: item.getY(),\r\n\t\t\t\theight: item.height\r\n\t\t\t}));\r\n\t\tconst allPointsCoords = _flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\r\n\t\t\t// points don't have width/height, so let's just use 0\r\n\t\t\tx: item.getX(),\r\n\t\t\twidth: 0,\r\n\t\t\ty: item.getY(),\r\n\t\t\theight: 0\r\n\t\t}));\r\n\r\n\t\tconst sumProps = (object, props) => _reduce(props, (acc, prop) => acc + _get(object, prop, 0), 0);\r\n\r\n\t\tconst canvas = this.engine.getCanvas() as HTMLDivElement;\r\n\t\tconst concatedCoords = _concat(allNodesCoords, allPortsCoords, allPointsCoords);\r\n\t\tconst minX =\r\n\t\t\tMath.floor(Math.min(_get(_minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\r\n\t\t\tthis.ROUTING_SCALING_FACTOR;\r\n\t\tconst maxXElement = _maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\r\n\t\tconst maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\r\n\t\tconst minYCoords = _minBy(concatedCoords, 'y');\r\n\t\tconst minY =\r\n\t\t\tMath.floor(Math.min(_get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\r\n\t\tconst maxYElement = _maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\r\n\t\tconst maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\r\n\r\n\t\treturn {\r\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\r\n\t\t\thAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\r\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\r\n\t\t\tvAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\r\n\t\t};\r\n\t};\r\n\r\n\t/**\r\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\r\n\t */\r\n\tmarkNodes = (matrix: number[][]): void => {\r\n\t\t_values(this.engine.getModel().getNodes()).forEach((node) => {\r\n\t\t\tconst startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\r\n\t\t\tconst endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\r\n\t\t\tconst startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\r\n\t\t\tconst endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\r\n\r\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\r\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\r\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/**\r\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\r\n\t */\r\n\tmarkPorts = (matrix: number[][]): void => {\r\n\t\tconst allElements = _flatMap(\r\n\t\t\t_values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort()))\r\n\t\t);\r\n\t\tallElements\r\n\t\t\t.filter((port) => port !== null)\r\n\t\t\t.forEach((port) => {\r\n\t\t\t\tconst startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\r\n\t\t\t\tconst endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\r\n\t\t\t\tconst startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\r\n\t\t\t\tconst endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\r\n\r\n\t\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\r\n\t\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\r\n\t\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t};\r\n\r\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\r\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\r\n\t\t\tmatrix[y][x] = 1;\r\n\t\t}\r\n\t};\r\n\r\n\tgenerateDynamicPath(pathCoords: number[][]) {\r\n\t\tlet path = Path();\r\n\t\tpath = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\r\n\t\tpathCoords.slice(1).forEach((coords) => {\r\n\t\t\tpath = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\r\n\t\t});\r\n\t\treturn path.print();\r\n\t}\r\n}\r\n","import { PathFindingLinkFactory } from './PathFindingLinkFactory';\r\nimport { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\r\n\r\nexport class PathFindingLinkModel extends DefaultLinkModel {\r\n\tconstructor(options: DefaultLinkModelOptions = {}) {\r\n\t\tsuper({\r\n\t\t\ttype: PathFindingLinkFactory.NAME,\r\n\t\t\t...options\r\n\t\t});\r\n\t}\r\n\r\n\tperformanceTune() {\r\n\t\treturn false;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport _first from 'lodash/first';\r\nimport _last from 'lodash/last';\r\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\r\nimport { PathFinding } from '../engine/PathFinding';\r\nimport { PathFindingLinkFactory } from './PathFindingLinkFactory';\r\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\r\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\r\n\r\nexport interface PathFindingLinkWidgetProps {\r\n\tcolor?: string;\r\n\twidth?: number;\r\n\tsmooth?: boolean;\r\n\tlink: PathFindingLinkModel;\r\n\tdiagramEngine: DiagramEngine;\r\n\tfactory: PathFindingLinkFactory;\r\n}\r\n\r\nexport interface PathFindingLinkWidgetState {\r\n\tselected: boolean;\r\n}\r\n\r\nexport class PathFindingLinkWidget extends React.Component<PathFindingLinkWidgetProps, PathFindingLinkWidgetState> {\r\n\trefPaths: React.RefObject<SVGPathElement>[];\r\n\tpathFinding: PathFinding;\r\n\r\n\tconstructor(props: PathFindingLinkWidgetProps) {\r\n\t\tsuper(props);\r\n\t\tthis.refPaths = [];\r\n\t\tthis.state = {\r\n\t\t\tselected: false\r\n\t\t};\r\n\t\tthis.pathFinding = new PathFinding(this.props.factory);\r\n\t}\r\n\r\n\tcomponentDidUpdate(): void {\r\n\t\tthis.props.link.setRenderedPaths(\r\n\t\t\tthis.refPaths.map((ref) => {\r\n\t\t\t\treturn ref.current;\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentDidMount(): void {\r\n\t\tthis.props.link.setRenderedPaths(\r\n\t\t\tthis.refPaths.map((ref) => {\r\n\t\t\t\treturn ref.current;\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnmount(): void {\r\n\t\tthis.props.link.setRenderedPaths([]);\r\n\t}\r\n\r\n\tgenerateLink(path: string, id: string | number): JSX.Element {\r\n\t\tconst ref = React.createRef<SVGPathElement>();\r\n\t\tthis.refPaths.push(ref);\r\n\t\treturn (\r\n\t\t\t<DefaultLinkSegmentWidget\r\n\t\t\t\tkey={`link-${id}`}\r\n\t\t\t\tpath={path}\r\n\t\t\t\tselected={this.state.selected}\r\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\r\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\r\n\t\t\t\tlink={this.props.link}\r\n\t\t\t\tforwardRef={ref}\r\n\t\t\t\tonSelection={(selected) => {\r\n\t\t\t\t\tthis.setState({ selected: selected });\r\n\t\t\t\t}}\r\n\t\t\t\textras={{}}\r\n\t\t\t/>\r\n\t\t);\r\n\t}\r\n\r\n\trender() {\r\n\t\tthis.refPaths = [];\r\n\t\t//ensure id is present for all points on the path\r\n\t\tvar points = this.props.link.getPoints();\r\n\t\tvar paths = [];\r\n\r\n\t\t// first step: calculate a direct path between the points being linked\r\n\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_first(points), _last(points));\r\n\r\n\t\tconst routingMatrix = this.props.factory.getRoutingMatrix();\r\n\t\t// now we need to extract, from the routing matrix, the very first walkable points\r\n\t\t// so they can be used as origin and destination of the link to be created\r\n\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\r\n\t\tif (smartLink) {\r\n\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\r\n\r\n\t\t\t// second step: calculate a path avoiding hitting other elements\r\n\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\r\n\r\n\t\t\tpaths.push(\r\n\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\r\n\t\t\t\tthis.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0')\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn <>{paths}</>;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { RightAngleLinkWidget } from './RightAngleLinkWidget';\r\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\r\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\r\n\r\n/**\r\n * @author Daniel Lazar\r\n */\r\nexport class RightAngleLinkFactory extends DefaultLinkFactory<RightAngleLinkModel> {\r\n\tstatic NAME = 'rightAngle';\r\n\r\n\tconstructor() {\r\n\t\tsuper(RightAngleLinkFactory.NAME);\r\n\t}\r\n\r\n\tgenerateModel(event): RightAngleLinkModel {\r\n\t\treturn new RightAngleLinkModel();\r\n\t}\r\n\r\n\tgenerateReactWidget(event): JSX.Element {\r\n\t\treturn <RightAngleLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\r\n\t}\r\n}\r\n","import { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\r\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\r\nimport { PointModel } from '@projectstorm/react-diagrams-core';\r\nimport { DeserializeEvent } from '@projectstorm/react-canvas-core';\r\n\r\nexport class RightAngleLinkModel extends DefaultLinkModel {\r\n\tlastHoverIndexOfPath: number;\r\n\tprivate _lastPathXdirection: boolean;\r\n\tprivate _firstPathXdirection: boolean;\r\n\tconstructor(options: DefaultLinkModelOptions = {}) {\r\n\t\tsuper({\r\n\t\t\ttype: RightAngleLinkFactory.NAME,\r\n\t\t\t...options\r\n\t\t});\r\n\t\tthis.lastHoverIndexOfPath = 0;\r\n\t\tthis._lastPathXdirection = false;\r\n\t\tthis._firstPathXdirection = false;\r\n\t}\r\n\r\n\tsetFirstAndLastPathsDirection() {\r\n\t\tlet points = this.getPoints();\r\n\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\r\n\t\t\tlet dx = Math.abs(points[i].getX() - points[i - 1].getX());\r\n\t\t\tlet dy = Math.abs(points[i].getY() - points[i - 1].getY());\r\n\t\t\tif (i - 1 === 0) {\r\n\t\t\t\tthis._firstPathXdirection = dx > dy;\r\n\t\t\t} else {\r\n\t\t\t\tthis._lastPathXdirection = dx > dy;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// @ts-ignore\r\n\taddPoint<P extends PointModel>(pointModel: P, index: number = 1): P {\r\n\t\t// @ts-ignore\r\n\t\tsuper.addPoint(pointModel, index);\r\n\t\tthis.setFirstAndLastPathsDirection();\r\n\t\treturn pointModel;\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.setFirstAndLastPathsDirection();\r\n\t}\r\n\r\n\tsetManuallyFirstAndLastPathsDirection(first, last) {\r\n\t\tthis._firstPathXdirection = first;\r\n\t\tthis._lastPathXdirection = last;\r\n\t}\r\n\r\n\tgetLastPathXdirection(): boolean {\r\n\t\treturn this._lastPathXdirection;\r\n\t}\r\n\tgetFirstPathXdirection(): boolean {\r\n\t\treturn this._firstPathXdirection;\r\n\t}\r\n\r\n\tsetWidth(width: number) {\r\n\t\tthis.options.width = width;\r\n\t\tthis.fireEvent({ width }, 'widthChanged');\r\n\t}\r\n\r\n\tsetColor(color: string) {\r\n\t\tthis.options.color = color;\r\n\t\tthis.fireEvent({ color }, 'colorChanged');\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\r\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\r\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\r\nimport { Point } from '@projectstorm/geometry';\r\nimport { MouseEvent } from 'react';\r\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\r\n\r\nexport interface RightAngleLinkProps {\r\n\tcolor?: string;\r\n\twidth?: number;\r\n\tsmooth?: boolean;\r\n\tlink: RightAngleLinkModel;\r\n\tdiagramEngine: DiagramEngine;\r\n\tfactory: RightAngleLinkFactory;\r\n}\r\n\r\nexport interface RightAngleLinkState {\r\n\tselected: boolean;\r\n\tcanDrag: boolean;\r\n}\r\n\r\nexport class RightAngleLinkWidget extends React.Component<RightAngleLinkProps, RightAngleLinkState> {\r\n\tpublic static defaultProps: RightAngleLinkProps = {\r\n\t\tcolor: 'red',\r\n\t\twidth: 3,\r\n\t\tlink: null,\r\n\t\tsmooth: false,\r\n\t\tdiagramEngine: null,\r\n\t\tfactory: null\r\n\t};\r\n\r\n\trefPaths: React.RefObject<SVGPathElement>[];\r\n\r\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\r\n\trefLabels: { [id: string]: HTMLElement };\r\n\tdragging_index: number;\r\n\r\n\tconstructor(props: RightAngleLinkProps) {\r\n\t\tsuper(props);\r\n\r\n\t\tthis.refPaths = [];\r\n\t\tthis.state = {\r\n\t\t\tselected: false,\r\n\t\t\tcanDrag: false\r\n\t\t};\r\n\r\n\t\tthis.dragging_index = 0;\r\n\t}\r\n\r\n\tcomponentDidUpdate(): void {\r\n\t\tthis.props.link.setRenderedPaths(\r\n\t\t\tthis.refPaths.map((ref) => {\r\n\t\t\t\treturn ref.current;\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentDidMount(): void {\r\n\t\tthis.props.link.setRenderedPaths(\r\n\t\t\tthis.refPaths.map((ref) => {\r\n\t\t\t\treturn ref.current;\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\tcomponentWillUnmount(): void {\r\n\t\tthis.props.link.setRenderedPaths([]);\r\n\t}\r\n\r\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\r\n\t\tconst ref = React.createRef<SVGPathElement>();\r\n\t\tthis.refPaths.push(ref);\r\n\t\treturn (\r\n\t\t\t<DefaultLinkSegmentWidget\r\n\t\t\t\tkey={`link-${id}`}\r\n\t\t\t\tpath={path}\r\n\t\t\t\tselected={this.state.selected}\r\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\r\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\r\n\t\t\t\tlink={this.props.link}\r\n\t\t\t\tforwardRef={ref}\r\n\t\t\t\tonSelection={(selected) => {\r\n\t\t\t\t\tthis.setState({ selected: selected });\r\n\t\t\t\t}}\r\n\t\t\t\textras={extraProps}\r\n\t\t\t/>\r\n\t\t);\r\n\t}\r\n\r\n\tcalculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\r\n\t\t// If path is first or last add another point to keep node port on its position\r\n\t\tif (index === 0) {\r\n\t\t\tlet point = new PointModel({\r\n\t\t\t\tlink: this.props.link,\r\n\t\t\t\tposition: new Point(points[index].getX(), points[index].getY())\r\n\t\t\t});\r\n\t\t\tthis.props.link.addPoint(point, index);\r\n\t\t\tthis.dragging_index++;\r\n\t\t\treturn;\r\n\t\t} else if (index === points.length - 2) {\r\n\t\t\tlet point = new PointModel({\r\n\t\t\t\tlink: this.props.link,\r\n\t\t\t\tposition: new Point(points[index + 1].getX(), points[index + 1].getY())\r\n\t\t\t});\r\n\t\t\tthis.props.link.addPoint(point, index + 1);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Merge two points if it is not close to node port and close to each other\r\n\t\tif (index - 2 > 0) {\r\n\t\t\tlet _points = {\r\n\t\t\t\t[index - 2]: points[index - 2].getPosition(),\r\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\r\n\t\t\t\t[index - 1]: points[index - 1].getPosition()\r\n\t\t\t};\r\n\t\t\tif (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\r\n\t\t\t\t_points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\r\n\t\t\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\r\n\t\t\t\tpoints[index - 2].setPosition(_points[index - 2]);\r\n\t\t\t\tpoints[index + 1].setPosition(_points[index + 1]);\r\n\t\t\t\tpoints[index - 1].remove();\r\n\t\t\t\tpoints[index - 1].remove();\r\n\t\t\t\tthis.dragging_index--;\r\n\t\t\t\tthis.dragging_index--;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Merge two points if it is not close to node port\r\n\t\tif (index + 2 < points.length - 2) {\r\n\t\t\tlet _points = {\r\n\t\t\t\t[index + 3]: points[index + 3].getPosition(),\r\n\t\t\t\t[index + 2]: points[index + 2].getPosition(),\r\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\r\n\t\t\t\t[index]: points[index].getPosition()\r\n\t\t\t};\r\n\t\t\tif (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\r\n\t\t\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\r\n\t\t\t\t_points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\r\n\t\t\t\tpoints[index].setPosition(_points[index]);\r\n\t\t\t\tpoints[index + 3].setPosition(_points[index + 3]);\r\n\t\t\t\tpoints[index + 1].remove();\r\n\t\t\t\tpoints[index + 1].remove();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If no condition above handled then just update path points position\r\n\t\tlet _points = {\r\n\t\t\t[index]: points[index].getPosition(),\r\n\t\t\t[index + 1]: points[index + 1].getPosition()\r\n\t\t};\r\n\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\r\n\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\r\n\t\tpoints[index].setPosition(_points[index]);\r\n\t\tpoints[index + 1].setPosition(_points[index + 1]);\r\n\t}\r\n\r\n\tdraggingEvent(event: MouseEvent, index: number) {\r\n\t\tlet points = this.props.link.getPoints();\r\n\t\t// get moving difference. Index + 1 will work because links indexes has\r\n\t\t// length = points.lenght - 1\r\n\t\tlet dx = Math.abs(points[index].getX() - points[index + 1].getX());\r\n\t\tlet dy = Math.abs(points[index].getY() - points[index + 1].getY());\r\n\r\n\t\t// moving with y direction\r\n\t\tif (dx === 0) {\r\n\t\t\tthis.calculatePositions(points, event, index, 'x');\r\n\t\t} else if (dy === 0) {\r\n\t\t\tthis.calculatePositions(points, event, index, 'y');\r\n\t\t}\r\n\t\tthis.props.link.setFirstAndLastPathsDirection();\r\n\t}\r\n\r\n\thandleMove = function (event: MouseEvent) {\r\n\t\tthis.draggingEvent(event, this.dragging_index);\r\n\t}.bind(this);\r\n\r\n\thandleUp = function (event: MouseEvent) {\r\n\t\t// Unregister handlers to avoid multiple event handlers for other links\r\n\t\tthis.setState({ canDrag: false, selected: false });\r\n\t\twindow.removeEventListener('mousemove', this.handleMove);\r\n\t\twindow.removeEventListener('mouseup', this.handleUp);\r\n\t}.bind(this);\r\n\r\n\trender() {\r\n\t\t//ensure id is present for all points on the path\r\n\t\tlet points = this.props.link.getPoints();\r\n\t\tlet paths = [];\r\n\r\n\t\t// Get points based on link orientation\r\n\t\tlet pointLeft = points[0];\r\n\t\tlet pointRight = points[points.length - 1];\r\n\t\tlet hadToSwitch = false;\r\n\t\tif (pointLeft.getX() > pointRight.getX()) {\r\n\t\t\tpointLeft = points[points.length - 1];\r\n\t\t\tpointRight = points[0];\r\n\t\t\thadToSwitch = true;\r\n\t\t}\r\n\t\tlet dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\r\n\r\n\t\t// When new link add one middle point to get everywhere 90° angle\r\n\t\tif (this.props.link.getTargetPort() === null && points.length === 2) {\r\n\t\t\t[...Array(2)].forEach((item) => {\r\n\t\t\t\tthis.props.link.addPoint(\r\n\t\t\t\t\tnew PointModel({\r\n\t\t\t\t\t\tlink: this.props.link,\r\n\t\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\r\n\t\t\t\t\t}),\r\n\t\t\t\t\t1\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t\tthis.props.link.setManuallyFirstAndLastPathsDirection(true, true);\r\n\t\t}\r\n\t\t// When new link is moving and not connected to target port move with middle point\r\n\t\t// TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\r\n\t\t//  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\r\n\t\telse if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\r\n\t\t\tpoints[1].setPosition(\r\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\r\n\t\t\t\t!hadToSwitch ? pointLeft.getY() : pointRight.getY()\r\n\t\t\t);\r\n\t\t\tpoints[2].setPosition(\r\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\r\n\t\t\t\t!hadToSwitch ? pointRight.getY() : pointLeft.getY()\r\n\t\t\t);\r\n\t\t}\r\n\t\t// Render was called but link is not moved but user.\r\n\t\t// Node is moved and in this case fix coordinates to get 90° angle.\r\n\t\t// For loop just for first and last path\r\n\t\telse if (!this.state.canDrag && points.length > 2) {\r\n\t\t\t// Those points and its position only will be moved\r\n\t\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\r\n\t\t\t\tif (i - 1 === 0) {\r\n\t\t\t\t\tif (this.props.link.getFirstPathXdirection()) {\r\n\t\t\t\t\t\tpoints[i].setPosition(points[i].getX(), points[i - 1].getY());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpoints[i].setPosition(points[i - 1].getX(), points[i].getY());\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (this.props.link.getLastPathXdirection()) {\r\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If there is existing link which has two points add one\r\n\t\t// NOTE: It doesn't matter if check is for dy or dx\r\n\t\tif (points.length === 2 && dy !== 0 && !this.state.canDrag) {\r\n\t\t\tthis.props.link.addPoint(\r\n\t\t\t\tnew PointModel({\r\n\t\t\t\t\tlink: this.props.link,\r\n\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tfor (let j = 0; j < points.length - 1; j++) {\r\n\t\t\tpaths.push(\r\n\t\t\t\tthis.generateLink(\r\n\t\t\t\t\tLinkWidget.generateLinePath(points[j], points[j + 1]),\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t'data-linkid': this.props.link.getID(),\r\n\t\t\t\t\t\t'data-point': j,\r\n\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\r\n\t\t\t\t\t\t\tif (event.button === 0) {\r\n\t\t\t\t\t\t\t\tthis.setState({ canDrag: true });\r\n\t\t\t\t\t\t\t\tthis.dragging_index = j;\r\n\t\t\t\t\t\t\t\t// Register mouse move event to track mouse position\r\n\t\t\t\t\t\t\t\t// On mouse up these events are unregistered check \"this.handleUp\"\r\n\t\t\t\t\t\t\t\twindow.addEventListener('mousemove', this.handleMove);\r\n\t\t\t\t\t\t\t\twindow.addEventListener('mouseup', this.handleUp);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tonMouseEnter: (event: MouseEvent) => {\r\n\t\t\t\t\t\t\tthis.setState({ selected: true });\r\n\t\t\t\t\t\t\tthis.props.link.lastHoverIndexOfPath = j;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tj\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis.refPaths = [];\r\n\t\treturn <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\r\n\t}\r\n}\r\n","module.exports = require(\"@projectstorm/geometry\");","module.exports = require(\"@projectstorm/react-canvas-core\");","module.exports = require(\"@projectstorm/react-diagrams-core\");","module.exports = require(\"@projectstorm/react-diagrams-defaults\");","module.exports = require(\"dagre\");","module.exports = require(\"lodash/cloneDeep\");","module.exports = require(\"lodash/concat\");","module.exports = require(\"lodash/defer\");","module.exports = require(\"lodash/every\");","module.exports = require(\"lodash/findIndex\");","module.exports = require(\"lodash/first\");","module.exports = require(\"lodash/flatMap\");","module.exports = require(\"lodash/forEach\");","module.exports = require(\"lodash/get\");","module.exports = require(\"lodash/last\");","module.exports = require(\"lodash/map\");","module.exports = require(\"lodash/maxBy\");","module.exports = require(\"lodash/minBy\");","module.exports = require(\"lodash/range\");","module.exports = require(\"lodash/reduce\");","module.exports = require(\"lodash/sortBy\");","module.exports = require(\"lodash/values\");","module.exports = require(\"pathfinding\");","module.exports = require(\"paths-js/path\");","module.exports = require(\"react\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * from './link/PathFindingLinkFactory';\r\nexport * from './link/PathFindingLinkModel';\r\nexport * from './link/PathFindingLinkWidget';\r\nexport * from './link/RightAngleLinkWidget';\r\nexport * from './link/RightAngleLinkFactory';\r\nexport * from './link/RightAngleLinkModel';\r\n\r\nexport * from './engine/PathFinding';\r\nexport * from './dagre/DagreEngine';\r\n"],"names":[],"sourceRoot":""}