{"version":3,"file":"index.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAuBA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClMA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhCA;AACA;;;;;;;;;;;;;;;;;;;;ACFA;AAEA;AACA;AAYA;;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7CA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9DA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9DA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwBA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpDA;AAEA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AAEA;AAiCA;AAGA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;ACnHA;AAQA;AAoBA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnHA;AAEA;AAgBA;AAMA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpEA;AACA;AAWA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;;;ACxGA;AAEA;AAMA;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxHA;AAEA;AAMA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;;;;;;;;;;;;;;;AClDA;;;AAGA;AACA;AAWA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AAQA;AAQA;;;;;;;;;;;;;;;;ACfA;AAOA;;AAEA;AACA;AAQA;;;;;;;;;;;;;;;;ACnBA;AA+CA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAIA;AACA;AAKA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/IA;AAEA;AAcA;;AAEA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE7DA;AACA;AACA;AACA;AACA;AACA;AAiCA;AAGA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAOA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7MA;AAEA;AACA;AACA;AAOA;AAAA;AACA;;;;AAIA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAuBA;AACA;;;;;;;;;;;;;;;;;;;;;;AC1IA;AAEA;AACA;AACA;AAmBA;AAKA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnHA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AAGA;AAMA;AAAA;AACA;;;;;;;;;;;AAWA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClBA;AACA;AAOA;AAAA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;ACjCA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AAUA;AAMA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxDA;AAEA;AACA;AAIA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;AC9BA;AAEA;AACA;AAcA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1FA;AACA;AAWA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjCA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA","sources":["webpack://projectstorm/react-canvas-core/webpack/universalModuleDefinition","webpack://projectstorm/react-canvas-core/./src/CanvasEngine.ts","webpack://projectstorm/react-canvas-core/./src/Toolkit.ts","webpack://projectstorm/react-canvas-core/./src/actions/DeleteItemsAction.ts","webpack://projectstorm/react-canvas-core/./src/actions/PanAndZoomCanvasAction.ts","webpack://projectstorm/react-canvas-core/./src/actions/ZoomCanvasAction.ts","webpack://projectstorm/react-canvas-core/./src/core-actions/Action.ts","webpack://projectstorm/react-canvas-core/./src/core-actions/ActionEventBus.ts","webpack://projectstorm/react-canvas-core/./src/core-models/BaseEntity.ts","webpack://projectstorm/react-canvas-core/./src/core-models/BaseModel.ts","webpack://projectstorm/react-canvas-core/./src/core-models/BasePositionModel.ts","webpack://projectstorm/react-canvas-core/./src/core-state/AbstractDisplacementState.ts","webpack://projectstorm/react-canvas-core/./src/core-state/State.ts","webpack://projectstorm/react-canvas-core/./src/core-state/StateMachine.ts","webpack://projectstorm/react-canvas-core/./src/core/AbstractFactory.ts","webpack://projectstorm/react-canvas-core/./src/core/AbstractModelFactory.ts","webpack://projectstorm/react-canvas-core/./src/core/AbstractReactFactory.tsx","webpack://projectstorm/react-canvas-core/./src/core/BaseObserver.ts","webpack://projectstorm/react-canvas-core/./src/core/FactoryBank.ts","webpack://projectstorm/react-canvas-core/./src/core/ModelGeometryInterface.ts","webpack://projectstorm/react-canvas-core/./src/entities/canvas/CanvasModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/canvas/CanvasWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/layer/LayerModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/layer/SmartLayerWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/layer/TransformLayerWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/selection/SelectionBoxLayerFactory.tsx","webpack://projectstorm/react-canvas-core/./src/entities/selection/SelectionBoxWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/selection/SelectionLayerModel.ts","webpack://projectstorm/react-canvas-core/./src/states/DefaultState.ts","webpack://projectstorm/react-canvas-core/./src/states/DragCanvasState.ts","webpack://projectstorm/react-canvas-core/./src/states/MoveItemsState.ts","webpack://projectstorm/react-canvas-core/./src/states/SelectingState.ts","webpack://projectstorm/react-canvas-core/./src/states/SelectionBoxState.ts","webpack://projectstorm/react-canvas-core/./src/widgets/PeformanceWidget.tsx","webpack://projectstorm/react-canvas-core/external commonjs \"@emotion/react\"","webpack://projectstorm/react-canvas-core/external commonjs \"@emotion/styled\"","webpack://projectstorm/react-canvas-core/external commonjs \"@projectstorm/geometry\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/cloneDeep\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/debounce\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/filter\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/flatMap\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/forEach\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/intersection\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/isEqual\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/keys\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/last\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/map\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/mapValues\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/values\"","webpack://projectstorm/react-canvas-core/external commonjs \"react\"","webpack://projectstorm/react-canvas-core/webpack/bootstrap","webpack://projectstorm/react-canvas-core/webpack/runtime/compat get default export","webpack://projectstorm/react-canvas-core/webpack/runtime/define property getters","webpack://projectstorm/react-canvas-core/webpack/runtime/hasOwnProperty shorthand","webpack://projectstorm/react-canvas-core/webpack/runtime/make namespace object","webpack://projectstorm/react-canvas-core/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"projectstorm/react-canvas-core\"] = factory();\n\telse\n\t\troot[\"projectstorm/react-canvas-core\"] = factory();\n})(self, () => {\nreturn ","import _debounce from 'lodash/debounce';\r\nimport { CanvasModel } from './entities/canvas/CanvasModel';\r\nimport { FactoryBank } from './core/FactoryBank';\r\nimport { AbstractReactFactory } from './core/AbstractReactFactory';\r\nimport { LayerModel } from './entities/layer/LayerModel';\r\nimport { BaseListener, BaseObserver } from './core/BaseObserver';\r\nimport { MouseEvent } from 'react';\r\nimport { BaseModel } from './core-models/BaseModel';\r\nimport { Point } from '@projectstorm/geometry';\r\nimport { ActionEventBus } from './core-actions/ActionEventBus';\r\nimport { PanAndZoomCanvasAction } from './actions/PanAndZoomCanvasAction';\r\nimport { ZoomCanvasAction } from './actions/ZoomCanvasAction';\r\nimport { DeleteItemsAction } from './actions/DeleteItemsAction';\r\nimport { StateMachine } from './core-state/StateMachine';\r\n\r\nexport interface CanvasEngineListener extends BaseListener {\r\n\tcanvasReady?(): void;\r\n\r\n\trepaintCanvas?(): void;\r\n\r\n\trendered?(): void;\r\n}\r\n\r\n/**\r\n * Defines the CanvasEngine options\r\n */\r\nexport interface CanvasEngineOptions {\r\n\tregisterDefaultDeleteItemsAction?: boolean;\r\n\tregisterDefaultPanAndZoomCanvasAction?: boolean;\r\n\tregisterDefaultZoomCanvasAction?: boolean;\r\n\t/**\r\n\t * Defines the debounce wait time in milliseconds if > 0\r\n\t */\r\n\trepaintDebounceMs?: number;\r\n}\r\n\r\nexport class CanvasEngine<\r\n\tL extends CanvasEngineListener = CanvasEngineListener,\r\n\tM extends CanvasModel = CanvasModel\r\n> extends BaseObserver<L> {\r\n\tprotected model: M;\r\n\tprotected layerFactories: FactoryBank<AbstractReactFactory<LayerModel>>;\r\n\tprotected canvas: HTMLDivElement;\r\n\tprotected eventBus: ActionEventBus;\r\n\tprotected stateMachine: StateMachine;\r\n\tprotected options: CanvasEngineOptions;\r\n\r\n\tconstructor(options: CanvasEngineOptions = {}) {\r\n\t\tsuper();\r\n\t\tthis.model = null;\r\n\t\tthis.eventBus = new ActionEventBus(this);\r\n\t\tthis.stateMachine = new StateMachine(this);\r\n\t\tthis.layerFactories = new FactoryBank();\r\n\t\tthis.registerFactoryBank(this.layerFactories);\r\n\r\n\t\t/**\r\n\t\t * Overrides the standard options with the possible given options\r\n\t\t */\r\n\t\tthis.options = {\r\n\t\t\tregisterDefaultDeleteItemsAction: true,\r\n\t\t\tregisterDefaultZoomCanvasAction: true,\r\n\t\t\trepaintDebounceMs: 0,\r\n\t\t\t...options\r\n\t\t};\r\n\t\tif (this.options.registerDefaultZoomCanvasAction === true) {\r\n\t\t\tthis.eventBus.registerAction(new ZoomCanvasAction());\r\n\t\t} else if (this.options.registerDefaultPanAndZoomCanvasAction === true) {\r\n\t\t\tthis.eventBus.registerAction(new PanAndZoomCanvasAction());\r\n\t\t}\r\n\t\tif (this.options.registerDefaultDeleteItemsAction === true) {\r\n\t\t\tthis.eventBus.registerAction(new DeleteItemsAction());\r\n\t\t}\r\n\t}\r\n\r\n\tgetStateMachine() {\r\n\t\treturn this.stateMachine;\r\n\t}\r\n\r\n\tgetRelativeMousePoint(event: { clientX: number; clientY: number }): Point {\r\n\t\tconst point = this.getRelativePoint(event.clientX, event.clientY);\r\n\t\treturn new Point(\r\n\t\t\t(point.x - this.model.getOffsetX()) / (this.model.getZoomLevel() / 100.0),\r\n\t\t\t(point.y - this.model.getOffsetY()) / (this.model.getZoomLevel() / 100.0)\r\n\t\t);\r\n\t}\r\n\r\n\tgetRelativePoint(x, y): Point {\r\n\t\tconst canvasRect = this.canvas.getBoundingClientRect();\r\n\t\treturn new Point(x - canvasRect.left, y - canvasRect.top);\r\n\t}\r\n\r\n\tregisterFactoryBank(factory: FactoryBank) {\r\n\t\tfactory.registerListener({\r\n\t\t\tfactoryAdded: (event) => {\r\n\t\t\t\tevent.factory.setDiagramEngine(this);\r\n\t\t\t},\r\n\t\t\tfactoryRemoved: (event) => {\r\n\t\t\t\tevent.factory.setDiagramEngine(null);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tgetActionEventBus() {\r\n\t\treturn this.eventBus;\r\n\t}\r\n\r\n\tgetLayerFactories() {\r\n\t\treturn this.layerFactories;\r\n\t}\r\n\r\n\tgetFactoryForLayer<F extends AbstractReactFactory<LayerModel>>(layer: LayerModel | string) {\r\n\t\tif (typeof layer === 'string') {\r\n\t\t\treturn this.layerFactories.getFactory(layer);\r\n\t\t}\r\n\t\treturn this.layerFactories.getFactory(layer.getType());\r\n\t}\r\n\r\n\tsetModel(model: M) {\r\n\t\tthis.model = model;\r\n\t\tif (this.canvas) {\r\n\t\t\trequestAnimationFrame(() => {\r\n\t\t\t\tthis.repaintCanvas();\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tgetModel(): M {\r\n\t\treturn this.model;\r\n\t}\r\n\r\n\trepaintCanvas(promise: true): Promise<any>;\r\n\trepaintCanvas(): void;\r\n\trepaintCanvas(promise?): Promise<any> | void {\r\n\t\tconst { repaintDebounceMs } = this.options;\r\n\r\n\t\t/**\r\n\t\t * The actual repaint function\r\n\t\t */\r\n\t\tconst repaint = () => {\r\n\t\t\tthis.iterateListeners((listener) => {\r\n\t\t\t\tif (listener.repaintCanvas) {\r\n\t\t\t\t\tlistener.repaintCanvas();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t// if the `repaintDebounceMs` option is > 0, then apply the debounce\r\n\t\tlet repaintFn = repaint;\r\n\r\n\t\tif (repaintDebounceMs > 0) {\r\n\t\t\trepaintFn = _debounce(repaint, repaintDebounceMs);\r\n\t\t}\r\n\r\n\t\tif (promise) {\r\n\t\t\treturn new Promise<void>((resolve) => {\r\n\t\t\t\tconst l = this.registerListener({\r\n\t\t\t\t\trendered: () => {\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\tl.deregister();\r\n\t\t\t\t\t}\r\n\t\t\t\t} as L);\r\n\t\t\t\trepaintFn();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trepaintFn();\r\n\t}\r\n\r\n\tsetCanvas(canvas?: HTMLDivElement) {\r\n\t\tif (this.canvas !== canvas) {\r\n\t\t\tthis.canvas = canvas;\r\n\t\t\tif (canvas) {\r\n\t\t\t\tthis.fireEvent({}, 'canvasReady');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgetCanvas() {\r\n\t\treturn this.canvas;\r\n\t}\r\n\r\n\tgetMouseElement(event: MouseEvent): BaseModel {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tzoomToFit() {\r\n\t\tconst xFactor = this.canvas.clientWidth / this.canvas.scrollWidth;\r\n\t\tconst yFactor = this.canvas.clientHeight / this.canvas.scrollHeight;\r\n\t\tconst zoomFactor = xFactor < yFactor ? xFactor : yFactor;\r\n\r\n\t\tthis.model.setZoomLevel(this.model.getZoomLevel() * zoomFactor);\r\n\t\tthis.model.setOffset(0, 0);\r\n\t\tthis.repaintCanvas();\r\n\t}\r\n}\r\n","export class Toolkit {\r\n\tstatic TESTING: boolean = false;\r\n\tstatic TESTING_UID = 0;\r\n\r\n\t/**\r\n\t * Generats a unique ID (thanks Stack overflow :3)\r\n\t * @returns {String}\r\n\t */\r\n\tpublic static UID(): string {\r\n\t\tif (Toolkit.TESTING) {\r\n\t\t\tToolkit.TESTING_UID++;\r\n\t\t\treturn `${Toolkit.TESTING_UID}`;\r\n\t\t}\r\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n\t\t\tconst r = (Math.random() * 16) | 0;\r\n\t\t\tconst v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n\t\t\treturn v.toString(16);\r\n\t\t});\r\n\t}\r\n\r\n\tpublic static closest(element: Element, selector: string) {\r\n\t\tif (!Element.prototype.closest) {\r\n\t\t\tElement.prototype.closest = function (s) {\r\n\t\t\t\tvar el = this;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (Element.prototype.matches.call(el, s)) return el;\r\n\t\t\t\t\tel = el.parentElement || el.parentNode;\r\n\t\t\t\t} while (el !== null && el.nodeType === 1);\r\n\t\t\t\treturn null;\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn element.closest(selector);\r\n\t}\r\n}\r\n","import { Action, ActionEvent, InputType } from '../core-actions/Action';\r\nimport { KeyboardEvent } from 'react';\r\nimport _forEach from 'lodash/forEach';\r\nimport _isEqual from 'lodash/isEqual';\r\n\r\nexport interface DeleteItemsActionOptions {\r\n\tkeyCodes?: number[];\r\n\tmodifiers?: {\r\n\t\tctrlKey?: boolean;\r\n\t\tshiftKey?: boolean;\r\n\t\taltKey?: boolean;\r\n\t\tmetaKey?: boolean;\r\n\t};\r\n}\r\n\r\n/**\r\n * Deletes all selected items\r\n */\r\nexport class DeleteItemsAction extends Action {\r\n\tconstructor(options: DeleteItemsActionOptions = {}) {\r\n\t\tconst keyCodes = options.keyCodes || [46, 8];\r\n\t\tconst modifiers = {\r\n\t\t\tctrlKey: false,\r\n\t\t\tshiftKey: false,\r\n\t\t\taltKey: false,\r\n\t\t\tmetaKey: false,\r\n\t\t\t...options.modifiers\r\n\t\t};\r\n\r\n\t\tsuper({\r\n\t\t\ttype: InputType.KEY_DOWN,\r\n\t\t\tfire: (event: ActionEvent<KeyboardEvent>) => {\r\n\t\t\t\tconst { keyCode, ctrlKey, shiftKey, altKey, metaKey } = event.event;\r\n\r\n\t\t\t\tif (keyCodes.indexOf(keyCode) !== -1 && _isEqual({ ctrlKey, shiftKey, altKey, metaKey }, modifiers)) {\r\n\t\t\t\t\t_forEach(this.engine.getModel().getSelectedEntities(), (model) => {\r\n\t\t\t\t\t\t// only delete items which are not locked\r\n\t\t\t\t\t\tif (!model.isLocked()) {\r\n\t\t\t\t\t\t\tmodel.remove();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n","import { WheelEvent } from 'react';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\n\r\nexport interface PanAndZoomCanvasActionOptions {\r\n\tinverseZoom?: boolean;\r\n}\r\n\r\nexport class PanAndZoomCanvasAction extends Action {\r\n\tconstructor(options: PanAndZoomCanvasActionOptions = {}) {\r\n\t\tsuper({\r\n\t\t\ttype: InputType.MOUSE_WHEEL,\r\n\t\t\tfire: (actionEvent: ActionEvent<WheelEvent>) => {\r\n\t\t\t\tconst { event } = actionEvent;\r\n\t\t\t\t// we can block layer rendering because we are only targeting the transforms\r\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\r\n\t\t\t\t\tlayer.allowRepaint(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst model = this.engine.getModel();\r\n\t\t\t\tevent.stopPropagation();\r\n\t\t\t\tif (event.ctrlKey) {\r\n\t\t\t\t\t// Pinch and zoom gesture\r\n\t\t\t\t\tconst oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\r\n\r\n\t\t\t\t\tlet scrollDelta = options.inverseZoom ? event.deltaY : -event.deltaY;\r\n\t\t\t\t\tscrollDelta /= 3;\r\n\r\n\t\t\t\t\tif (model.getZoomLevel() + scrollDelta > 10) {\r\n\t\t\t\t\t\tmodel.setZoomLevel(model.getZoomLevel() + scrollDelta);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst zoomFactor = model.getZoomLevel() / 100;\r\n\r\n\t\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\r\n\t\t\t\t\tconst clientWidth = boundingRect.width;\r\n\t\t\t\t\tconst clientHeight = boundingRect.height;\r\n\t\t\t\t\t// compute difference between rect before and after scroll\r\n\t\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\r\n\t\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\r\n\t\t\t\t\t// compute mouse coords relative to canvas\r\n\t\t\t\t\tconst clientX = event.clientX - boundingRect.left;\r\n\t\t\t\t\tconst clientY = event.clientY - boundingRect.top;\r\n\r\n\t\t\t\t\t// compute width and height increment factor\r\n\t\t\t\t\tconst xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\r\n\t\t\t\t\tconst yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\r\n\r\n\t\t\t\t\tmodel.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Pan gesture\r\n\t\t\t\t\tlet yDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\r\n\t\t\t\t\tlet xDelta = options.inverseZoom ? -event.deltaX : event.deltaX;\r\n\t\t\t\t\tmodel.setOffset(model.getOffsetX() - xDelta, model.getOffsetY() - yDelta);\r\n\t\t\t\t}\r\n\t\t\t\tthis.engine.repaintCanvas();\r\n\r\n\t\t\t\t// re-enable rendering\r\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\r\n\t\t\t\t\tlayer.allowRepaint(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n","import { WheelEvent } from 'react';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\n\r\nexport interface ZoomCanvasActionOptions {\r\n\tinverseZoom?: boolean;\r\n}\r\n\r\nexport class ZoomCanvasAction extends Action {\r\n\tconstructor(options: ZoomCanvasActionOptions = {}) {\r\n\t\tsuper({\r\n\t\t\ttype: InputType.MOUSE_WHEEL,\r\n\t\t\tfire: (actionEvent: ActionEvent<WheelEvent>) => {\r\n\t\t\t\tconst { event } = actionEvent;\r\n\t\t\t\t// we can block layer rendering because we are only targeting the transforms\r\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\r\n\t\t\t\t\tlayer.allowRepaint(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst model = this.engine.getModel();\r\n\t\t\t\tevent.stopPropagation();\r\n\t\t\t\tconst oldZoomFactor = this.engine.getModel().getZoomLevel() / 100;\r\n\t\t\t\tlet scrollDelta = options.inverseZoom ? -event.deltaY : event.deltaY;\r\n\t\t\t\t//check if it is pinch gesture\r\n\t\t\t\tif (event.ctrlKey && scrollDelta % 1 !== 0) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t\tChrome and Firefox sends wheel event with deltaY that\r\n\t\t\t\t\t\thave fractional part, also `ctrlKey` prop of the event is true\r\n\t\t\t\t\t\tthough ctrl isn't pressed\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tscrollDelta /= 3;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tscrollDelta /= 60;\r\n\t\t\t\t}\r\n\t\t\t\tif (model.getZoomLevel() + scrollDelta > 10) {\r\n\t\t\t\t\tmodel.setZoomLevel(model.getZoomLevel() + scrollDelta);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst zoomFactor = model.getZoomLevel() / 100;\r\n\r\n\t\t\t\tconst boundingRect = event.currentTarget.getBoundingClientRect();\r\n\t\t\t\tconst clientWidth = boundingRect.width;\r\n\t\t\t\tconst clientHeight = boundingRect.height;\r\n\t\t\t\t// compute difference between rect before and after scroll\r\n\t\t\t\tconst widthDiff = clientWidth * zoomFactor - clientWidth * oldZoomFactor;\r\n\t\t\t\tconst heightDiff = clientHeight * zoomFactor - clientHeight * oldZoomFactor;\r\n\t\t\t\t// compute mouse coords relative to canvas\r\n\t\t\t\tconst clientX = event.clientX - boundingRect.left;\r\n\t\t\t\tconst clientY = event.clientY - boundingRect.top;\r\n\r\n\t\t\t\t// compute width and height increment factor\r\n\t\t\t\tconst xFactor = (clientX - model.getOffsetX()) / oldZoomFactor / clientWidth;\r\n\t\t\t\tconst yFactor = (clientY - model.getOffsetY()) / oldZoomFactor / clientHeight;\r\n\r\n\t\t\t\tmodel.setOffset(model.getOffsetX() - widthDiff * xFactor, model.getOffsetY() - heightDiff * yFactor);\r\n\t\t\t\tthis.engine.repaintCanvas();\r\n\r\n\t\t\t\t// re-enable rendering\r\n\t\t\t\tfor (let layer of this.engine.getModel().getLayers()) {\r\n\t\t\t\t\tlayer.allowRepaint(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n","import { MouseEvent, KeyboardEvent, WheelEvent, TouchEvent, SyntheticEvent } from 'react';\r\nimport { Toolkit } from '../Toolkit';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\nimport { BaseModel } from '../core-models/BaseModel';\r\n\r\nexport enum InputType {\r\n\tMOUSE_DOWN = 'mouse-down',\r\n\tMOUSE_UP = 'mouse-up',\r\n\tMOUSE_MOVE = 'mouse-move',\r\n\tMOUSE_WHEEL = 'mouse-wheel',\r\n\tKEY_DOWN = 'key-down',\r\n\tKEY_UP = 'key-up',\r\n\tTOUCH_START = 'touch-start',\r\n\tTOUCH_END = 'touch-end',\r\n\tTOUCH_MOVE = 'touch-move'\r\n}\r\n\r\nexport interface Mapping {\r\n\t[InputType.MOUSE_DOWN]: MouseEvent;\r\n\t[InputType.MOUSE_UP]: MouseEvent;\r\n\t[InputType.MOUSE_MOVE]: MouseEvent;\r\n\t[InputType.MOUSE_WHEEL]: WheelEvent;\r\n\t[InputType.KEY_DOWN]: KeyboardEvent;\r\n\t[InputType.KEY_UP]: KeyboardEvent;\r\n\t[InputType.TOUCH_START]: TouchEvent;\r\n\t[InputType.TOUCH_END]: TouchEvent;\r\n\t[InputType.TOUCH_MOVE]: TouchEvent;\r\n}\r\n\r\nexport interface ActionEvent<Event extends SyntheticEvent = SyntheticEvent, Model extends BaseModel = BaseModel> {\r\n\tevent: Event;\r\n\tmodel?: Model;\r\n}\r\n\r\nexport interface ActionOptions {\r\n\ttype: InputType;\r\n\tfire: (event: ActionEvent<Mapping[this['type']]>) => void;\r\n}\r\n\r\nexport class Action<T extends CanvasEngine = CanvasEngine> {\r\n\toptions: ActionOptions;\r\n\tid: string;\r\n\tengine: T;\r\n\r\n\tconstructor(options: ActionOptions) {\r\n\t\tthis.options = options;\r\n\t\tthis.id = Toolkit.UID();\r\n\t}\r\n\r\n\tsetEngine(engine: T) {\r\n\t\tthis.engine = engine;\r\n\t}\r\n}\r\n","import { Action, ActionEvent, InputType } from './Action';\r\nimport { KeyboardEvent, MouseEvent } from 'react';\r\nimport _filter from 'lodash/filter';\r\nimport _keys from 'lodash/keys';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\nimport { BaseModel } from '../core-models/BaseModel';\r\n\r\nexport class ActionEventBus {\r\n\tprotected actions: { [id: string]: Action };\r\n\tprotected engine: CanvasEngine;\r\n\tprotected keys: { [key: string]: boolean };\r\n\r\n\tconstructor(engine: CanvasEngine) {\r\n\t\tthis.actions = {};\r\n\t\tthis.engine = engine;\r\n\t\tthis.keys = {};\r\n\t}\r\n\r\n\tgetKeys(): string[] {\r\n\t\treturn _keys(this.keys);\r\n\t}\r\n\r\n\tregisterAction(action: Action): () => void {\r\n\t\taction.setEngine(this.engine);\r\n\t\tthis.actions[action.id] = action;\r\n\t\treturn () => {\r\n\t\t\tthis.deregisterAction(action);\r\n\t\t};\r\n\t}\r\n\r\n\tderegisterAction(action: Action) {\r\n\t\taction.setEngine(null);\r\n\t\tdelete this.actions[action.id];\r\n\t}\r\n\r\n\tgetActionsForType(type: InputType): Action[] {\r\n\t\treturn _filter(this.actions, (action) => {\r\n\t\t\treturn action.options.type === type;\r\n\t\t});\r\n\t}\r\n\r\n\tgetModelForEvent(actionEvent: ActionEvent<MouseEvent>): BaseModel {\r\n\t\tif (actionEvent.model) {\r\n\t\t\treturn actionEvent.model;\r\n\t\t}\r\n\t\treturn this.engine.getMouseElement(actionEvent.event);\r\n\t}\r\n\r\n\tgetActionsForEvent(actionEvent: ActionEvent): Action[] {\r\n\t\tconst { event } = actionEvent;\r\n\t\tif (event.type === 'mousedown') {\r\n\t\t\treturn this.getActionsForType(InputType.MOUSE_DOWN);\r\n\t\t} else if (event.type === 'mouseup') {\r\n\t\t\treturn this.getActionsForType(InputType.MOUSE_UP);\r\n\t\t} else if (event.type === 'keydown') {\r\n\t\t\t// store the recorded key\r\n\t\t\tthis.keys[(event as KeyboardEvent).key.toLowerCase()] = true;\r\n\t\t\treturn this.getActionsForType(InputType.KEY_DOWN);\r\n\t\t} else if (event.type === 'keyup') {\r\n\t\t\t// delete the recorded key\r\n\t\t\tdelete this.keys[(event as KeyboardEvent).key.toLowerCase()];\r\n\t\t\treturn this.getActionsForType(InputType.KEY_UP);\r\n\t\t} else if (event.type === 'mousemove') {\r\n\t\t\treturn this.getActionsForType(InputType.MOUSE_MOVE);\r\n\t\t} else if (event.type === 'wheel') {\r\n\t\t\treturn this.getActionsForType(InputType.MOUSE_WHEEL);\r\n\t\t} else if (event.type === 'touchstart') {\r\n\t\t\treturn this.getActionsForType(InputType.TOUCH_START);\r\n\t\t} else if (event.type === 'touchend') {\r\n\t\t\treturn this.getActionsForType(InputType.TOUCH_END);\r\n\t\t} else if (event.type === 'touchmove') {\r\n\t\t\treturn this.getActionsForType(InputType.TOUCH_MOVE);\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t}\r\n\r\n\tfireAction(actionEvent: ActionEvent) {\r\n\t\tconst actions = this.getActionsForEvent(actionEvent);\r\n\t\tfor (let action of actions) {\r\n\t\t\taction.options.fire(actionEvent as any);\r\n\t\t}\r\n\t}\r\n}\r\n","import { Toolkit } from '../Toolkit';\r\nimport _cloneDeep from 'lodash/cloneDeep';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\nimport { BaseEvent, BaseListener, BaseObserver } from '../core/BaseObserver';\r\nimport { BaseModel } from './BaseModel';\r\n\r\nexport interface BaseEntityEvent<T extends BaseEntity = BaseEntity> extends BaseEvent {\r\n\tentity: T;\r\n}\r\n\r\nexport interface BaseEntityListener<T extends BaseEntity = BaseEntity> extends BaseListener {\r\n\tlockChanged?(event: BaseEntityEvent<T> & { locked: boolean }): void;\r\n}\r\n\r\n/**\r\n * @TODO move to enums\r\n */\r\nexport type BaseEntityType = 'node' | 'link' | 'port' | 'point';\r\n\r\nexport interface BaseEntityOptions {\r\n\tid?: string;\r\n\tlocked?: boolean;\r\n}\r\n\r\nexport type BaseEntityGenerics = {\r\n\tLISTENER: BaseEntityListener;\r\n\tOPTIONS: BaseEntityOptions;\r\n};\r\n\r\nexport interface DeserializeEvent<T extends BaseEntity = BaseEntity> {\r\n\tengine: CanvasEngine;\r\n\tdata: ReturnType<T['serialize']>;\r\n\tregisterModel(model: BaseModel);\r\n\tgetModel<T extends BaseModel>(id: string): Promise<T>;\r\n}\r\n\r\nexport class BaseEntity<T extends BaseEntityGenerics = BaseEntityGenerics> extends BaseObserver<T['LISTENER']> {\r\n\tprotected options: T['OPTIONS'];\r\n\r\n\tconstructor(options: T['OPTIONS'] = {}) {\r\n\t\tsuper();\r\n\t\tthis.options = {\r\n\t\t\tid: Toolkit.UID(),\r\n\t\t\t...options\r\n\t\t};\r\n\t}\r\n\r\n\tgetOptions() {\r\n\t\treturn this.options;\r\n\t}\r\n\r\n\tgetID() {\r\n\t\treturn this.options.id;\r\n\t}\r\n\r\n\tdoClone(lookupTable: { [s: string]: any } = {}, clone: any) {\r\n\t\t/*noop*/\r\n\t}\r\n\r\n\tclone(lookupTable: { [s: string]: any } = {}) {\r\n\t\t// try and use an existing clone first\r\n\t\tif (lookupTable[this.options.id]) {\r\n\t\t\treturn lookupTable[this.options.id];\r\n\t\t}\r\n\t\tlet clone = _cloneDeep(this);\r\n\t\tclone.options = {\r\n\t\t\t...this.options,\r\n\t\t\tid: Toolkit.UID()\r\n\t\t};\r\n\t\tclone.clearListeners();\r\n\t\tlookupTable[this.options.id] = clone;\r\n\r\n\t\tthis.doClone(lookupTable, clone);\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tclearListeners() {\r\n\t\tthis.listeners = {};\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tthis.options.id = event.data.id;\r\n\t\tthis.options.locked = event.data.locked;\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\tid: this.options.id,\r\n\t\t\tlocked: this.options.locked\r\n\t\t};\r\n\t}\r\n\r\n\tfireEvent<L extends Partial<BaseEntityEvent> & object>(event: L, k: keyof T['LISTENER']) {\r\n\t\tsuper.fireEvent(\r\n\t\t\t{\r\n\t\t\t\tentity: this,\r\n\t\t\t\t...event\r\n\t\t\t},\r\n\t\t\tk\r\n\t\t);\r\n\t}\r\n\r\n\tpublic isLocked(): boolean {\r\n\t\treturn this.options.locked;\r\n\t}\r\n\r\n\tpublic setLocked(locked: boolean = true) {\r\n\t\tthis.options.locked = locked;\r\n\t\tthis.fireEvent(\r\n\t\t\t{\r\n\t\t\t\tlocked: locked\r\n\t\t\t},\r\n\t\t\t'lockChanged'\r\n\t\t);\r\n\t}\r\n}\r\n","import {\r\n\tBaseEntity,\r\n\tBaseEntityEvent,\r\n\tBaseEntityGenerics,\r\n\tBaseEntityListener,\r\n\tBaseEntityOptions,\r\n\tDeserializeEvent\r\n} from './BaseEntity';\r\nimport { CanvasModel } from '../entities/canvas/CanvasModel';\r\n\r\nexport interface BaseModelListener extends BaseEntityListener {\r\n\tselectionChanged?(event: BaseEntityEvent<BaseModel> & { isSelected: boolean }): void;\r\n\r\n\tentityRemoved?(event: BaseEntityEvent<BaseModel>): void;\r\n}\r\n\r\nexport interface BaseModelOptions extends BaseEntityOptions {\r\n\ttype?: string;\r\n\tselected?: boolean;\r\n\textras?: any;\r\n}\r\n\r\nexport interface BaseModelGenerics extends BaseEntityGenerics {\r\n\tLISTENER: BaseModelListener;\r\n\tPARENT: BaseEntity;\r\n\tOPTIONS: BaseModelOptions;\r\n}\r\n\r\nexport class BaseModel<G extends BaseModelGenerics = BaseModelGenerics> extends BaseEntity<G> {\r\n\tprotected parent: G['PARENT'];\r\n\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper(options);\r\n\t}\r\n\r\n\tperformanceTune() {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tgetParentCanvasModel(): CanvasModel {\r\n\t\tif (!this.parent) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (this.parent instanceof CanvasModel) {\r\n\t\t\treturn this.parent;\r\n\t\t} else if (this.parent instanceof BaseModel) {\r\n\t\t\treturn this.parent.getParentCanvasModel();\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tgetParent(): G['PARENT'] {\r\n\t\treturn this.parent;\r\n\t}\r\n\r\n\tsetParent(parent: G['PARENT']) {\r\n\t\tthis.parent = parent;\r\n\t}\r\n\r\n\tgetSelectionEntities(): Array<BaseModel> {\r\n\t\treturn [this];\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\ttype: this.options.type,\r\n\t\t\tselected: this.options.selected,\r\n\t\t\textras: this.options.extras\r\n\t\t};\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.options.extras = event.data.extras;\r\n\t\tthis.options.selected = event.data.selected;\r\n\t}\r\n\r\n\tgetType(): string {\r\n\t\treturn this.options.type;\r\n\t}\r\n\r\n\tisSelected(): boolean {\r\n\t\treturn this.options.selected;\r\n\t}\r\n\r\n\tisLocked(): boolean {\r\n\t\tconst locked = super.isLocked();\r\n\t\tif (locked) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// delegate this call up to the parent\r\n\t\tif (this.parent) {\r\n\t\t\treturn this.parent.isLocked();\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tsetSelected(selected: boolean = true) {\r\n\t\tif (this.options.selected !== selected) {\r\n\t\t\tthis.options.selected = selected;\r\n\r\n\t\t\tthis.fireEvent(\r\n\t\t\t\t{\r\n\t\t\t\t\tisSelected: selected\r\n\t\t\t\t},\r\n\t\t\t\t'selectionChanged'\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tremove() {\r\n\t\tthis.fireEvent({}, 'entityRemoved');\r\n\t}\r\n}\r\n","import { BaseModel, BaseModelGenerics, BaseModelListener, BaseModelOptions } from './BaseModel';\r\nimport { BaseEntityEvent, DeserializeEvent } from './BaseEntity';\r\nimport { Point, Rectangle } from '@projectstorm/geometry';\r\nimport { ModelGeometryInterface } from '../core/ModelGeometryInterface';\r\n\r\nexport interface BasePositionModelListener extends BaseModelListener {\r\n\tpositionChanged?(event: BaseEntityEvent<BasePositionModel>): void;\r\n}\r\n\r\nexport interface BasePositionModelOptions extends BaseModelOptions {\r\n\tposition?: Point;\r\n}\r\n\r\nexport interface BasePositionModelGenerics extends BaseModelGenerics {\r\n\tLISTENER: BasePositionModelListener;\r\n\tOPTIONS: BasePositionModelOptions;\r\n}\r\n\r\nexport class BasePositionModel<G extends BasePositionModelGenerics = BasePositionModelGenerics>\r\n\textends BaseModel<G>\r\n\timplements ModelGeometryInterface\r\n{\r\n\tprotected position: Point;\r\n\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper(options);\r\n\t\tthis.position = options.position || new Point(0, 0);\r\n\t}\r\n\r\n\tsetPosition(point: Point): void;\r\n\tsetPosition(x: number, y: number): void;\r\n\tsetPosition(x: number | Point, y?: number): void {\r\n\t\tif (x instanceof Point) {\r\n\t\t\tthis.position = x;\r\n\t\t} else {\r\n\t\t\tthis.position = new Point(x, y);\r\n\t\t}\r\n\t\tthis.fireEvent({}, 'positionChanged');\r\n\t}\r\n\r\n\tgetBoundingBox(): Rectangle {\r\n\t\treturn Rectangle.fromPointAndSize(this.position, 0, 0);\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.position = new Point(event.data.x, event.data.y);\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\tx: this.position.x,\r\n\t\t\ty: this.position.y\r\n\t\t};\r\n\t}\r\n\r\n\tgetPosition(): Point {\r\n\t\treturn this.position;\r\n\t}\r\n\r\n\tgetX() {\r\n\t\treturn this.position.x;\r\n\t}\r\n\r\n\tgetY() {\r\n\t\treturn this.position.y;\r\n\t}\r\n}\r\n","import { State, StateOptions } from './State';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\n\r\nexport interface AbstractDisplacementStateEvent {\r\n\tdisplacementX: number;\r\n\tdisplacementY: number;\r\n\tvirtualDisplacementX: number;\r\n\tvirtualDisplacementY: number;\r\n\tevent: React.MouseEvent | React.TouchEvent;\r\n}\r\n\r\nexport abstract class AbstractDisplacementState<E extends CanvasEngine = CanvasEngine> extends State<E> {\r\n\tinitialX: number;\r\n\tinitialY: number;\r\n\tinitialXRelative: number;\r\n\tinitialYRelative: number;\r\n\r\n\tconstructor(options: StateOptions) {\r\n\t\tsuper(options);\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_DOWN,\r\n\t\t\t\tfire: (actionEvent: ActionEvent<React.MouseEvent>) => {\r\n\t\t\t\t\tconst { clientX, clientY } = actionEvent.event;\r\n\t\t\t\t\tthis.handleMoveStart(clientX, clientY);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_MOVE,\r\n\t\t\t\tfire: (actionEvent: ActionEvent<React.MouseEvent>) => {\r\n\t\t\t\t\tconst { event } = actionEvent;\r\n\r\n\t\t\t\t\tif (event.buttons === 0) {\r\n\t\t\t\t\t\t// If buttons is 0, it means the mouse is not down, the user may have released it\r\n\t\t\t\t\t\t// outside of the canvas, then we eject the state\r\n\t\t\t\t\t\tthis.eject();\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst { clientX, clientY } = event;\r\n\t\t\t\t\tthis.handleMove(clientX, clientY, event);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_UP,\r\n\t\t\t\tfire: () => this.handleMoveEnd()\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.TOUCH_START,\r\n\t\t\t\tfire: (actionEvent: ActionEvent<React.TouchEvent>) => {\r\n\t\t\t\t\tconst { clientX, clientY } = actionEvent.event.touches[0];\r\n\t\t\t\t\tthis.handleMoveStart(clientX, clientY);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.TOUCH_MOVE,\r\n\t\t\t\tfire: (actionEvent: ActionEvent<React.TouchEvent>) => {\r\n\t\t\t\t\tconst { event } = actionEvent;\r\n\t\t\t\t\tconst { clientX, clientY } = event.touches[0];\r\n\t\t\t\t\tthis.handleMove(clientX, clientY, event);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.TOUCH_END,\r\n\t\t\t\tfire: () => this.handleMoveEnd()\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\tprotected handleMoveStart(x: number, y: number): void {\r\n\t\tthis.initialX = x;\r\n\t\tthis.initialY = y;\r\n\t\tconst rel = this.engine.getRelativePoint(x, y);\r\n\t\tthis.initialXRelative = rel.x;\r\n\t\tthis.initialYRelative = rel.y;\r\n\t}\r\n\r\n\tprotected handleMove(x: number, y: number, event: React.MouseEvent | React.TouchEvent): void {\r\n\t\tthis.fireMouseMoved({\r\n\t\t\tdisplacementX: x - this.initialX,\r\n\t\t\tdisplacementY: y - this.initialY,\r\n\t\t\tvirtualDisplacementX: (x - this.initialX) / (this.engine.getModel().getZoomLevel() / 100.0),\r\n\t\t\tvirtualDisplacementY: (y - this.initialY) / (this.engine.getModel().getZoomLevel() / 100.0),\r\n\t\t\tevent\r\n\t\t});\r\n\t}\r\n\r\n\tprotected handleMoveEnd(): void {\r\n\t\tthis.eject();\r\n\t}\r\n\r\n\tabstract fireMouseMoved(event: AbstractDisplacementStateEvent);\r\n}\r\n","import { CanvasEngine } from '../CanvasEngine';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\nimport { SyntheticEvent } from 'react';\r\nimport _intersection from 'lodash/intersection';\r\n\r\nexport interface StateOptions {\r\n\tname: string;\r\n}\r\n\r\nexport abstract class State<E extends CanvasEngine = CanvasEngine> {\r\n\tprotected engine: E;\r\n\tprotected actions: Action[];\r\n\tprotected keys: string[];\r\n\tprotected options: StateOptions;\r\n\tprotected childStates: State[];\r\n\r\n\tprivate handler1;\r\n\tprivate handler2;\r\n\r\n\tconstructor(options: StateOptions) {\r\n\t\tthis.actions = [];\r\n\t\tthis.keys = [];\r\n\t\tthis.childStates = [];\r\n\t\tthis.options = options;\r\n\t}\r\n\r\n\tsetEngine(engine: E) {\r\n\t\tthis.engine = engine;\r\n\t}\r\n\r\n\tgetOptions() {\r\n\t\treturn this.options;\r\n\t}\r\n\r\n\teject() {\r\n\t\tthis.engine.getStateMachine().popState();\r\n\t}\r\n\r\n\ttransitionWithEvent(state: State, event: ActionEvent<SyntheticEvent>) {\r\n\t\tthis.engine.getStateMachine().pushState(state);\r\n\t\tthis.engine.getActionEventBus().fireAction(event);\r\n\t}\r\n\r\n\tregisterAction(action: Action) {\r\n\t\tthis.actions.push(action);\r\n\t}\r\n\r\n\ttryActivateParentState(keys: string[]) {\r\n\t\tif (this.keys.length > 0 && !this.isKeysFullfilled(keys)) {\r\n\t\t\tthis.eject();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\ttryActivateChildState(keys: string[]) {\r\n\t\tconst state = this.findStateToActivate(keys);\r\n\t\tif (state) {\r\n\t\t\tthis.engine.getStateMachine().pushState(state);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfindStateToActivate(keys: string[]) {\r\n\t\tfor (let child of this.childStates) {\r\n\t\t\tif (child.isKeysFullfilled(keys)) {\r\n\t\t\t\treturn child;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tisKeysFullfilled(keys: string[]) {\r\n\t\treturn _intersection(this.keys, keys).length === this.keys.length;\r\n\t}\r\n\r\n\tactivated(previous: State) {\r\n\t\tconst keys = this.engine.getActionEventBus().getKeys();\r\n\r\n\t\tif (this.tryActivateParentState(keys) || this.tryActivateChildState(keys)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// perhaps we need to pop again?\r\n\t\tthis.handler1 = this.engine.getActionEventBus().registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.KEY_DOWN,\r\n\t\t\t\tfire: () => {\r\n\t\t\t\t\tthis.tryActivateChildState(this.engine.getActionEventBus().getKeys());\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tthis.handler2 = this.engine.getActionEventBus().registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.KEY_UP,\r\n\t\t\t\tfire: () => {\r\n\t\t\t\t\tthis.tryActivateParentState(this.engine.getActionEventBus().getKeys());\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tfor (let action of this.actions) {\r\n\t\t\tthis.engine.getActionEventBus().registerAction(action);\r\n\t\t}\r\n\t}\r\n\r\n\tdeactivated(next: State) {\r\n\t\tif (this.handler1) {\r\n\t\t\tthis.handler1();\r\n\t\t}\r\n\t\tif (this.handler2) {\r\n\t\t\tthis.handler2();\r\n\t\t}\r\n\t\t// if this happens, we are going into heirachial state machine mode\r\n\t\tfor (let action of this.actions) {\r\n\t\t\tthis.engine.getActionEventBus().deregisterAction(action);\r\n\t\t}\r\n\t}\r\n}\r\n","import { State } from './State';\r\nimport _last from 'lodash/last';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\nimport { BaseEvent, BaseListener, BaseObserver } from '../core/BaseObserver';\r\n\r\nexport interface StateMachineListener extends BaseListener {\r\n\tstateChanged?: (event: BaseEvent & { newState: State }) => any;\r\n}\r\n\r\nexport class StateMachine extends BaseObserver<StateMachineListener> {\r\n\tprotected currentState: State;\r\n\tprotected stateStack: State[];\r\n\tprotected engine: CanvasEngine;\r\n\r\n\tconstructor(engine: CanvasEngine) {\r\n\t\tsuper();\r\n\t\tthis.engine = engine;\r\n\t\tthis.stateStack = [];\r\n\t}\r\n\r\n\tgetCurrentState() {\r\n\t\treturn this.currentState;\r\n\t}\r\n\r\n\tpushState(state: State) {\r\n\t\tthis.stateStack.push(state);\r\n\t\tthis.setState(state);\r\n\t}\r\n\r\n\tpopState() {\r\n\t\tthis.stateStack.pop();\r\n\t\tthis.setState(_last(this.stateStack));\r\n\t}\r\n\r\n\tsetState(state: State) {\r\n\t\tstate.setEngine(this.engine);\r\n\r\n\t\t// if no state object, get the initial state\r\n\t\tif (this.currentState) {\r\n\t\t\tthis.currentState.deactivated(state);\r\n\t\t}\r\n\t\tconst old = this.currentState;\r\n\t\tthis.currentState = state;\r\n\t\tif (this.currentState) {\r\n\t\t\tthis.currentState.activated(old);\r\n\t\t\tthis.fireEvent<'stateChanged'>(\r\n\t\t\t\t{\r\n\t\t\t\t\tnewState: state\r\n\t\t\t\t},\r\n\t\t\t\t'stateChanged'\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n","import { CanvasEngine } from '../CanvasEngine';\r\nimport { FactoryBank } from './FactoryBank';\r\n\r\n/**\r\n * Base factory for all the different types of entities.\r\n * Gets registered with the engine, and is used to generate models\r\n */\r\nexport abstract class AbstractFactory<E extends CanvasEngine = CanvasEngine> {\r\n\t/**\r\n\t * Couples the factory with the models it generates\r\n\t */\r\n\tprotected type: string;\r\n\t/**\r\n\t * The engine gets injected when the factory is registered\r\n\t */\r\n\tprotected engine: E;\r\n\tprotected bank: FactoryBank;\r\n\r\n\tconstructor(type: string) {\r\n\t\tthis.type = type;\r\n\t}\r\n\r\n\tsetDiagramEngine(engine: E) {\r\n\t\tthis.engine = engine;\r\n\t}\r\n\r\n\tsetFactoryBank(bank: FactoryBank) {\r\n\t\tthis.bank = bank;\r\n\t}\r\n\r\n\tgetType(): string {\r\n\t\treturn this.type;\r\n\t}\r\n}\r\n","import { AbstractFactory } from './AbstractFactory';\r\nimport { BaseModel } from '../core-models/BaseModel';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\n\r\nexport interface GenerateModelEvent {\r\n\tinitialConfig?: any;\r\n}\r\n\r\nexport abstract class AbstractModelFactory<\r\n\tT extends BaseModel = BaseModel,\r\n\tE extends CanvasEngine = CanvasEngine\r\n> extends AbstractFactory<E> {\r\n\t/**\r\n\t * Generates new models (the core factory pattern)\r\n\t */\r\n\tabstract generateModel(event: GenerateModelEvent): T;\r\n}\r\n","import { BaseModel } from '../core-models/BaseModel';\r\nimport { AbstractModelFactory } from './AbstractModelFactory';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\n\r\nexport interface GenerateWidgetEvent<T extends BaseModel> {\r\n\tmodel: T;\r\n}\r\n\r\n/**\r\n * Further extends the AbstractFactory to add widget generation capability.\r\n */\r\nexport abstract class AbstractReactFactory<\r\n\tT extends BaseModel = BaseModel,\r\n\tE extends CanvasEngine = CanvasEngine\r\n> extends AbstractModelFactory<T, E> {\r\n\t/**\r\n\t * Generates React widgets from the model contained in the event object\r\n\t */\r\n\tabstract generateReactWidget(event: GenerateWidgetEvent<T>): JSX.Element;\r\n}\r\n","import { Toolkit } from '../Toolkit';\r\n\r\nexport interface BaseEvent {\r\n\tfiring: boolean;\r\n\tstopPropagation: () => any;\r\n}\r\n\r\nexport interface BaseEventProxy extends BaseEvent {\r\n\tfunction: string;\r\n}\r\n\r\n/**\r\n * Listeners are always in the form of an object that contains methods that take events\r\n */\r\nexport type BaseListener = {\r\n\t/**\r\n\t * Generic event that fires before a specific event was fired\r\n\t */\r\n\teventWillFire?: (event: BaseEvent & { function: string }) => void;\r\n\r\n\t/**\r\n\t * Generic event that fires after a specific event was fired (even if it was consumed)\r\n\t */\r\n\teventDidFire?: (event: BaseEvent & { function: string }) => void;\r\n} & {\r\n\t/**\r\n\t * Type for other events that will fire\r\n\t */\r\n\t[key: string]: (event: BaseEvent) => any;\r\n};\r\n\r\nexport interface ListenerHandle {\r\n\t/**\r\n\t * Used to degister the listener\r\n\t */\r\n\tderegister: () => any;\r\n\t/**\r\n\t * Original ID of the listener\r\n\t */\r\n\tid: string;\r\n\r\n\t/**\r\n\t * Original Listener\r\n\t */\r\n\tlistener: BaseListener;\r\n}\r\n\r\n/**\r\n * Base observer pattern class for working with listeners\r\n */\r\nexport class BaseObserver<L extends BaseListener = BaseListener> {\r\n\tprotected listeners: { [id: string]: L };\r\n\r\n\tconstructor() {\r\n\t\tthis.listeners = {};\r\n\t}\r\n\r\n\tprivate fireEventInternal(fire: boolean, k: keyof L, event: BaseEvent) {\r\n\t\tthis.iterateListeners((listener) => {\r\n\t\t\t// returning false here will instruct itteration to stop\r\n\t\t\tif (!fire && !event.firing) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t// fire selected listener\r\n\t\t\tif (listener[k]) {\r\n\t\t\t\tlistener[k](event as BaseEvent);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tfireEvent<K extends keyof L>(event: Partial<Parameters<L[K]>[0]>, k: keyof L) {\r\n\t\tevent = {\r\n\t\t\tfiring: true,\r\n\t\t\tstopPropagation: () => {\r\n\t\t\t\tevent.firing = false;\r\n\t\t\t},\r\n\t\t\t...event\r\n\t\t};\r\n\r\n\t\t// fire pre\r\n\t\tthis.fireEventInternal(true, 'eventWillFire', {\r\n\t\t\t...event,\r\n\t\t\tfunction: k\r\n\t\t} as BaseEventProxy);\r\n\r\n\t\t// fire main event\r\n\t\tthis.fireEventInternal(false, k, event as BaseEvent);\r\n\r\n\t\t// fire post\r\n\t\tthis.fireEventInternal(true, 'eventDidFire', {\r\n\t\t\t...event,\r\n\t\t\tfunction: k\r\n\t\t} as BaseEventProxy);\r\n\t}\r\n\r\n\titerateListeners(cb: (listener: L) => any) {\r\n\t\tfor (let id in this.listeners) {\r\n\t\t\tconst res = cb(this.listeners[id]);\r\n\t\t\t// cancel itteration on false\r\n\t\t\tif (res === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgetListenerHandle(listener: L): ListenerHandle {\r\n\t\tfor (let id in this.listeners) {\r\n\t\t\tif (this.listeners[id] === listener) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tid: id,\r\n\t\t\t\t\tlistener: listener,\r\n\t\t\t\t\tderegister: () => {\r\n\t\t\t\t\t\tdelete this.listeners[id];\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tregisterListener(listener: L): ListenerHandle {\r\n\t\tconst id = Toolkit.UID();\r\n\t\tthis.listeners[id] = listener;\r\n\t\treturn {\r\n\t\t\tid: id,\r\n\t\t\tlistener: listener,\r\n\t\t\tderegister: () => {\r\n\t\t\t\tdelete this.listeners[id];\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tderegisterListener(listener: L | ListenerHandle) {\r\n\t\tif (typeof listener === 'object') {\r\n\t\t\t(listener as ListenerHandle).deregister();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tconst handle = this.getListenerHandle(listener);\r\n\t\tif (handle) {\r\n\t\t\thandle.deregister();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n","import { BaseEvent, BaseListener, BaseObserver } from './BaseObserver';\r\nimport { AbstractFactory } from './AbstractFactory';\r\nimport _values from 'lodash/values';\r\n\r\nexport interface FactoryBankListener<F extends AbstractFactory = AbstractFactory> extends BaseListener {\r\n\t/**\r\n\t * Factory as added to rhe bank\r\n\t */\r\n\tfactoryAdded?: (event: BaseEvent & { factory: F }) => any;\r\n\r\n\t/**\r\n\t * Factory was removed from the bank\r\n\t */\r\n\tfactoryRemoved?: (event: BaseEvent & { factory: F }) => any;\r\n}\r\n\r\n/**\r\n * Store and managed Factories that extend from Abstractfactory\r\n */\r\nexport class FactoryBank<\r\n\tF extends AbstractFactory = AbstractFactory,\r\n\tL extends FactoryBankListener<F> = FactoryBankListener<F>\r\n> extends BaseObserver<L> {\r\n\tprotected factories: { [type: string]: F };\r\n\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.factories = {};\r\n\t}\r\n\r\n\tgetFactories(): F[] {\r\n\t\treturn _values(this.factories);\r\n\t}\r\n\r\n\tclearFactories() {\r\n\t\tfor (let factory in this.factories) {\r\n\t\t\tthis.deregisterFactory(factory);\r\n\t\t}\r\n\t}\r\n\r\n\tgetFactory<T extends F = F>(type: string): T {\r\n\t\tif (!this.factories[type]) {\r\n\t\t\tthrow new Error(`Cannot find factory with type [${type}]`);\r\n\t\t}\r\n\t\treturn this.factories[type] as T;\r\n\t}\r\n\r\n\tregisterFactory(factory: F) {\r\n\t\tfactory.setFactoryBank(this);\r\n\t\tthis.factories[factory.getType()] = factory;\r\n\t\t// todo fixme\r\n\t\tthis.fireEvent<'factoryAdded'>({ factory } as any, 'factoryAdded');\r\n\t}\r\n\r\n\tderegisterFactory(type: string) {\r\n\t\tconst factory = this.factories[type];\r\n\t\tfactory.setFactoryBank(null);\r\n\t\tdelete this.factories[type];\r\n\t\t// todo fixme\r\n\t\tthis.fireEvent<'factoryRemoved'>({ factory } as any, 'factoryRemoved');\r\n\t}\r\n}\r\n","import { Rectangle } from '@projectstorm/geometry';\r\n\r\nexport interface ModelGeometryInterface {\r\n\tgetBoundingBox(): Rectangle;\r\n}\r\n","import _filter from 'lodash/filter';\r\nimport _flatMap from 'lodash/flatMap';\r\nimport _forEach from 'lodash/forEach';\r\nimport _map from 'lodash/map';\r\nimport _values from 'lodash/values';\r\nimport {\r\n\tBaseEntity,\r\n\tBaseEntityEvent,\r\n\tBaseEntityGenerics,\r\n\tBaseEntityListener,\r\n\tBaseEntityOptions,\r\n\tDeserializeEvent\r\n} from '../../core-models/BaseEntity';\r\nimport { LayerModel } from '../layer/LayerModel';\r\nimport { BaseModel } from '../../core-models/BaseModel';\r\nimport { CanvasEngine } from '../../CanvasEngine';\r\n\r\nexport interface CanvasModelListener extends BaseEntityListener {\r\n\toffsetUpdated?(event: BaseEntityEvent<CanvasModel> & { offsetX: number; offsetY: number }): void;\r\n\r\n\tzoomUpdated?(event: BaseEntityEvent<CanvasModel> & { zoom: number }): void;\r\n\r\n\tgridUpdated?(event: BaseEntityEvent<CanvasModel> & { size: number }): void;\r\n}\r\n\r\nexport interface CanvasModelOptions extends BaseEntityOptions {\r\n\toffsetX?: number;\r\n\toffsetY?: number;\r\n\tzoom?: number;\r\n\tgridSize?: number;\r\n}\r\n\r\nexport interface CanvasModelGenerics extends BaseEntityGenerics {\r\n\tLISTENER: CanvasModelListener;\r\n\tOPTIONS: CanvasModelOptions;\r\n\tLAYER: LayerModel;\r\n}\r\n\r\nexport class CanvasModel<G extends CanvasModelGenerics = CanvasModelGenerics> extends BaseEntity<G> {\r\n\tprotected layers: G['LAYER'][];\r\n\r\n\tconstructor(options: G['OPTIONS'] = {}) {\r\n\t\tsuper({\r\n\t\t\tzoom: 100,\r\n\t\t\tgridSize: 0,\r\n\t\t\toffsetX: 0,\r\n\t\t\toffsetY: 0,\r\n\t\t\t...options\r\n\t\t});\r\n\t\tthis.layers = [];\r\n\t}\r\n\r\n\tgetSelectionEntities(): BaseModel[] {\r\n\t\treturn _flatMap(this.layers, (layer) => {\r\n\t\t\treturn layer.getSelectionEntities();\r\n\t\t});\r\n\t}\r\n\r\n\tgetSelectedEntities(): BaseModel[] {\r\n\t\treturn _filter(this.getSelectionEntities(), (ob) => {\r\n\t\t\treturn ob.isSelected();\r\n\t\t});\r\n\t}\r\n\r\n\tclearSelection() {\r\n\t\t_forEach(this.getSelectedEntities(), (element) => {\r\n\t\t\telement.setSelected(false);\r\n\t\t});\r\n\t}\r\n\r\n\tgetModels(): BaseModel[] {\r\n\t\treturn _flatMap(this.layers, (layer) => {\r\n\t\t\treturn _values(layer.getModels());\r\n\t\t});\r\n\t}\r\n\r\n\taddLayer(layer: LayerModel) {\r\n\t\tlayer.setParent(this);\r\n\t\tlayer.registerListener({\r\n\t\t\tentityRemoved: (event: BaseEntityEvent<BaseModel>): void => {}\r\n\t\t});\r\n\t\tthis.layers.push(layer);\r\n\t}\r\n\r\n\tremoveLayer(layer: LayerModel) {\r\n\t\tconst index = this.layers.indexOf(layer);\r\n\t\tif (index !== -1) {\r\n\t\t\tthis.layers.splice(index, 1);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tgetLayers() {\r\n\t\treturn this.layers;\r\n\t}\r\n\r\n\tsetGridSize(size: number = 0) {\r\n\t\tthis.options.gridSize = size;\r\n\t\tthis.fireEvent({ size: size }, 'gridUpdated');\r\n\t}\r\n\r\n\tgetGridPosition(pos: number) {\r\n\t\tif (this.options.gridSize === 0) {\r\n\t\t\treturn pos;\r\n\t\t}\r\n\t\treturn this.options.gridSize * Math.floor((pos + this.options.gridSize / 2) / this.options.gridSize);\r\n\t}\r\n\r\n\tdeserializeModel(data: ReturnType<this['serialize']>, engine: CanvasEngine) {\r\n\t\tconst models: {\r\n\t\t\t[id: string]: BaseModel;\r\n\t\t} = {};\r\n\t\tconst promises: {\r\n\t\t\t[id: string]: Promise<BaseModel>;\r\n\t\t} = {};\r\n\t\tconst resolvers: {\r\n\t\t\t[id: string]: (model: BaseModel) => any;\r\n\t\t} = {};\r\n\r\n\t\tconst event: DeserializeEvent = {\r\n\t\t\tdata: data,\r\n\t\t\tengine: engine,\r\n\t\t\tregisterModel: (model: BaseModel) => {\r\n\t\t\t\tmodels[model.getID()] = model;\r\n\t\t\t\tif (resolvers[model.getID()]) {\r\n\t\t\t\t\tresolvers[model.getID()](model);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tgetModel<T extends BaseModel>(id: string): Promise<T> {\r\n\t\t\t\tif (models[id]) {\r\n\t\t\t\t\treturn Promise.resolve(models[id]) as Promise<T>;\r\n\t\t\t\t}\r\n\t\t\t\tif (!promises[id]) {\r\n\t\t\t\t\tpromises[id] = new Promise((resolve) => {\r\n\t\t\t\t\t\tresolvers[id] = resolve;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn promises[id] as Promise<T>;\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.deserialize(event);\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.options.offsetX = event.data.offsetX;\r\n\t\tthis.options.offsetY = event.data.offsetY;\r\n\t\tthis.options.zoom = event.data.zoom;\r\n\t\tthis.options.gridSize = event.data.gridSize;\r\n\t\t_forEach(event.data.layers, (layer) => {\r\n\t\t\tconst layerOb = event.engine.getFactoryForLayer(layer.type).generateModel({\r\n\t\t\t\tinitialConfig: layer\r\n\t\t\t});\r\n\t\t\tlayerOb.deserialize({\r\n\t\t\t\t...event,\r\n\t\t\t\tdata: layer\r\n\t\t\t});\r\n\t\t\tthis.addLayer(layerOb);\r\n\t\t});\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\toffsetX: this.options.offsetX,\r\n\t\t\toffsetY: this.options.offsetY,\r\n\t\t\tzoom: this.options.zoom,\r\n\t\t\tgridSize: this.options.gridSize,\r\n\t\t\tlayers: _map(this.layers, (layer) => {\r\n\t\t\t\treturn layer.serialize();\r\n\t\t\t})\r\n\t\t};\r\n\t}\r\n\r\n\tsetZoomLevel(zoom: number) {\r\n\t\tthis.options.zoom = zoom;\r\n\t\tthis.fireEvent({ zoom }, 'zoomUpdated');\r\n\t}\r\n\r\n\tsetOffset(offsetX: number, offsetY: number) {\r\n\t\tthis.options.offsetX = offsetX;\r\n\t\tthis.options.offsetY = offsetY;\r\n\t\tthis.fireEvent({ offsetX, offsetY }, 'offsetUpdated');\r\n\t}\r\n\r\n\tsetOffsetX(offsetX: number) {\r\n\t\tthis.setOffset(offsetX, this.options.offsetY);\r\n\t}\r\n\r\n\tsetOffsetY(offsetY: number) {\r\n\t\tthis.setOffset(this.options.offsetX, offsetY);\r\n\t}\r\n\r\n\tgetOffsetY() {\r\n\t\treturn this.options.offsetY;\r\n\t}\r\n\r\n\tgetOffsetX() {\r\n\t\treturn this.options.offsetX;\r\n\t}\r\n\r\n\tgetZoomLevel() {\r\n\t\treturn this.options.zoom;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { CanvasEngine } from '../../CanvasEngine';\r\nimport { TransformLayerWidget } from '../layer/TransformLayerWidget';\r\nimport styled from '@emotion/styled';\r\nimport { SmartLayerWidget } from '../layer/SmartLayerWidget';\r\n\r\nexport interface DiagramProps {\r\n\tengine: CanvasEngine;\r\n\tclassName?: string;\r\n}\r\n\r\nnamespace S {\r\n\texport const Canvas = styled.div`\r\n\t\tposition: relative;\r\n\t\tcursor: move;\r\n\t\toverflow: hidden;\r\n\t`;\r\n}\r\n\r\nexport class CanvasWidget extends React.Component<DiagramProps> {\r\n\tref: React.RefObject<HTMLDivElement>;\r\n\tkeyUp: any;\r\n\tkeyDown: any;\r\n\tcanvasListener: any;\r\n\r\n\tconstructor(props: DiagramProps) {\r\n\t\tsuper(props);\r\n\r\n\t\tthis.ref = React.createRef();\r\n\t\tthis.state = {\r\n\t\t\taction: null,\r\n\t\t\tdiagramEngineListener: null\r\n\t\t};\r\n\t}\r\n\r\n\tcomponentWillUnmount() {\r\n\t\tthis.props.engine.deregisterListener(this.canvasListener);\r\n\t\tthis.props.engine.setCanvas(null);\r\n\r\n\t\tdocument.removeEventListener('keyup', this.keyUp);\r\n\t\tdocument.removeEventListener('keydown', this.keyDown);\r\n\t}\r\n\r\n\tregisterCanvas() {\r\n\t\tthis.props.engine.setCanvas(this.ref.current);\r\n\t\tthis.props.engine.iterateListeners((list) => {\r\n\t\t\tlist.rendered && list.rendered();\r\n\t\t});\r\n\t}\r\n\r\n\tcomponentDidUpdate() {\r\n\t\tthis.registerCanvas();\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\tthis.canvasListener = this.props.engine.registerListener({\r\n\t\t\trepaintCanvas: () => {\r\n\t\t\t\tthis.forceUpdate();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.keyDown = (event) => {\r\n\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t};\r\n\t\tthis.keyUp = (event) => {\r\n\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t};\r\n\r\n\t\tdocument.addEventListener('keyup', this.keyUp);\r\n\t\tdocument.addEventListener('keydown', this.keyDown);\r\n\t\tthis.registerCanvas();\r\n\t}\r\n\r\n\trender() {\r\n\t\tconst engine = this.props.engine;\r\n\t\tconst model = engine.getModel();\r\n\r\n\t\t console.log('model.getLayers()',model.getLayers()) \r\n\r\n\t\treturn (\r\n\t\t\t<S.Canvas\r\n\t\t\t\tclassName={this.props.className}\r\n\t\t\t\tref={this.ref}\r\n\t\t\t\tonWheel={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t\tonMouseDown={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t\tonMouseUp={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t\tonMouseMove={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t\tonTouchStart={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t\tonTouchEnd={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t\tonTouchMove={(event) => {\r\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\r\n\t\t\t\t}}\r\n\t\t\t>\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t        <TransformLayerWidget layer={model.getLayers()[1]} key={model.getLayers()[1].getID()}>\r\n\t\t\t\t\t\t\t\t<SmartLayerWidget layer={model.getLayers()[1]} engine={this.props.engine} key={model.getLayers()[1].getID()} />\r\n\t\t\t\t\t\t</TransformLayerWidget>\r\n\t\t\t\t\t\t<TransformLayerWidget layer={model.getLayers()[0]} key={model.getLayers()[0].getID()}>\r\n\t\t\t\t\t\t\t\t<SmartLayerWidget layer={model.getLayers()[0]} engine={this.props.engine} key={model.getLayers()[0].getID()} />\r\n\t\t\t\t\t\t\t</TransformLayerWidget>\r\n\t\t\t\t\t\t\t<TransformLayerWidget layer={model.getLayers()[1]} key={model.getLayers()[1].getID()}>\r\n\t\t\t\t\t\t\t\t<SmartLayerWidget layer={model.getLayers()[1]} engine={this.props.engine} key={model.getLayers()[1].getID()} />\r\n\t\t\t\t\t\t</TransformLayerWidget>\r\n\t\t\t\t\t\t\r\n\t\t\t\t{/* {model.getLayers().map((layer) => {\r\n\t\t\t\t\tif(layer.getIsWorktable() === true)\r\n\t\t\t\t\treturn ( //nodos\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif(layer.getIsWorktable() === false)\r\n\t\t\t\t\t\treturn ( //links\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t );\r\n\t\t\t\t\t if(layer.getIsWorktable() === false)\r\n\t\t\t\t\t\treturn ( //nodos\r\n\t\t\t\t\t\t\t<TransformLayerWidget layer={model.getLayers()[1]} key={model.getLayers()[1].getID()}>\r\n\t\t\t\t\t\t\t\t<SmartLayerWidget layer={model.getLayers()[1]} engine={this.props.engine} key={model.getLayers()[1].getID()} />\r\n\t\t\t\t\t\t</TransformLayerWidget>\r\n\t\t\t\t\t );\r\n\t\t\t\t})} */}\r\n \r\n\t\t\t \r\n\t\t\t</S.Canvas>\r\n\t\t);\r\n\t}\r\n}\r\n","import { BaseModel, BaseModelGenerics, BaseModelOptions } from '../../core-models/BaseModel';\r\nimport { CanvasModel } from '../canvas/CanvasModel';\r\nimport _flatMap from 'lodash/flatMap';\r\nimport _forEach from 'lodash/forEach';\r\nimport _mapValues from 'lodash/mapValues';\r\nimport { CanvasEngine } from '../../CanvasEngine';\r\nimport { FactoryBank } from '../../core/FactoryBank';\r\nimport { AbstractModelFactory } from '../../core/AbstractModelFactory';\r\nimport { DeserializeEvent } from '../../core-models/BaseEntity';\r\n\r\nexport interface LayerModelOptions extends BaseModelOptions {\r\n\tisSvg?: boolean;\r\n\ttransformed?: boolean;\r\n\tisWorktable? : boolean;\r\n}\r\n\r\nexport interface LayerModelGenerics extends BaseModelGenerics {\r\n\tOPTIONS: LayerModelOptions;\r\n\tPARENT: CanvasModel;\r\n\tCHILDREN: BaseModel;\r\n\tENGINE: CanvasEngine;\r\n}\r\n\r\nexport abstract class LayerModel<G extends LayerModelGenerics = LayerModelGenerics> extends BaseModel<G> {\r\n\tprotected models: { [id: string]: G['CHILDREN'] };\r\n\tprotected repaintEnabled: boolean;\r\n\tprotected isWorktable: boolean;\r\n\r\n\tconstructor(options: G['OPTIONS'] = {}) {\r\n\t\tsuper(options);\r\n\t\tthis.models = {};\r\n\t\tthis.isWorktable = false;\r\n\t\tthis.repaintEnabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * This is used for deserialization\r\n\t */\r\n\tabstract getChildModelFactoryBank(engine: G['ENGINE']): FactoryBank<AbstractModelFactory<BaseModel>>;\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.options.isSvg = !!event.data.isSvg;\r\n\t\tthis.options.isWorktable = !!event.data.isWorktable;\r\n\t\tthis.options.transformed = !!event.data.transformed;\r\n\t\t_forEach(event.data.models, (model) => {\r\n\t\t\tconst modelOb = this.getChildModelFactoryBank(event.engine).getFactory(model.type).generateModel({\r\n\t\t\t\tinitialConfig: model\r\n\t\t\t});\r\n\t\t\tmodelOb.deserialize({\r\n\t\t\t\t...event,\r\n\t\t\t\tdata: model\r\n\t\t\t});\r\n\t\t\tthis.addModel(modelOb);\r\n\t\t});\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\tisSvg: this.options.isSvg,\r\n\t\t\tisWorktable: this.options.isWorktable,\r\n\t\t\ttransformed: this.options.transformed,\r\n\t\t\tmodels: _mapValues(this.models, (model) => {\r\n\t\t\t\treturn model.serialize();\r\n\t\t\t})\r\n\t\t};\r\n\t}\r\n\r\n\tisRepaintEnabled() {\r\n\t\treturn this.repaintEnabled;\r\n\t}\r\n\r\n\tallowRepaint(allow: boolean = true) {\r\n\t\tthis.repaintEnabled = allow;\r\n\t}\r\n\r\n\tremove() {\r\n\t\tif (this.parent) {\r\n\t\t\tthis.parent.removeLayer(this);\r\n\t\t}\r\n\t\tsuper.remove();\r\n\t}\r\n\r\n\taddModel(model: G['CHILDREN']) {\r\n\t\tmodel.setParent(this);\r\n\t\tthis.models[model.getID()] = model;\r\n\t}\r\n\r\n\tgetSelectionEntities(): Array<BaseModel> {\r\n\t\treturn _flatMap(this.models, (model) => {\r\n\t\t\treturn model.getSelectionEntities();\r\n\t\t});\r\n\t}\r\n\r\n\tgetModels() {\r\n\t\treturn this.models;\r\n\t}\r\n\r\n\tgetIsWorktable(){\r\n\t\treturn this.options.isWorktable;\r\n\t}\r\n\r\n\tgetModel(id: string) {\r\n\t\treturn this.models[id];\r\n\t}\r\n\r\n\tremoveModel(id: string | G['CHILDREN']): boolean {\r\n\t\tconst _id = typeof id === 'string' ? id : id.getID();\r\n\t\tif (this.models[_id]) {\r\n\t\t\tdelete this.models[_id];\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { LayerModel } from './LayerModel';\r\nimport { CanvasEngine } from '../../CanvasEngine';\r\n\r\nexport interface SmartLayerWidgetProps {\r\n\tlayer: LayerModel;\r\n\tengine: CanvasEngine;\r\n}\r\n\r\nexport class SmartLayerWidget extends React.Component<SmartLayerWidgetProps> {\r\n\tshouldComponentUpdate(): boolean {\r\n\t\treturn this.props.layer.isRepaintEnabled();\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn this.props.engine.getFactoryForLayer(this.props.layer).generateReactWidget({ model: this.props.layer });\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport styled from '@emotion/styled';\r\nimport { CSSProperties } from 'react';\r\nimport { LayerModel } from './LayerModel';\r\nimport { css } from '@emotion/react';\r\n\r\nexport interface TransformLayerWidgetProps {\r\n\tlayer: LayerModel;\r\n}\r\n\r\nnamespace S {\r\n\tconst shared = css`\r\n\t\ttop: 0;\r\n\t\tleft: 0;\r\n\t\tright: 0;\r\n\t\tbottom: 0;\r\n\t\tposition: absolute;\r\n\t\tpointer-events: none;\r\n\t\ttransform-origin: 0 0;\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\toverflow: visible;\r\n\t`;\r\n\r\n\texport const DivLayer = styled.div`\r\n\t\t${shared}\r\n\t`;\r\n\r\n\texport const SvgLayer = styled.svg`\r\n\t\t${shared}\r\n\t`;\r\n}\r\n\r\nexport class TransformLayerWidget extends React.Component<React.PropsWithChildren<TransformLayerWidgetProps>> {\r\n\tconstructor(props: TransformLayerWidgetProps) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {};\r\n\t}\r\n\r\n\tgetTransform() {\r\n\t\tconst model = this.props.layer.getParent();\r\n\t\treturn `\r\n\t\t\ttranslate(\r\n\t\t\t\t${model.getOffsetX()}px,\r\n\t\t\t\t${model.getOffsetY()}px)\r\n\t\t\tscale(\r\n\t\t\t\t${model.getZoomLevel() / 100.0}\r\n\t\t\t)\r\n  \t`;\r\n\t}\r\n\r\n\tgetTransformStyle(): CSSProperties {\r\n\t\tif (this.props.layer.getOptions().transformed) {\r\n\t\t\treturn {\r\n\t\t\t\ttransform: this.getTransform()\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn {};\r\n\t}\r\n\r\n\trender() {\r\n\t\tif (this.props.layer.getOptions().isWorktable && this.props.layer.getOptions().isSvg===false) {\r\n\t\t\treturn <S.DivLayer style={this.getTransformStyle()}>{this.props.children}</S.DivLayer>;\r\n\t\t}\r\n\t\tif (this.props.layer.getOptions().isSvg) {\r\n\t\t\treturn <S.SvgLayer style={this.getTransformStyle()}>{this.props.children}</S.SvgLayer>;\r\n\t\t}\r\n\t\tif (!this.props.layer.getOptions().isWorktable && this.props.layer.getOptions().isSvg===false) {\r\n\t\t\treturn <S.DivLayer style={this.getTransformStyle()}>{this.props.children}</S.DivLayer>;\r\n\t\t}\r\n\t\t// return <S.DivLayer style={this.getTransformStyle()}>{this.props.children}</S.DivLayer>;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { AbstractReactFactory, GenerateWidgetEvent } from '../../core/AbstractReactFactory';\r\nimport { SelectionLayerModel } from './SelectionLayerModel';\r\nimport { GenerateModelEvent } from '../../core/AbstractModelFactory';\r\nimport { SelectionBoxWidget } from './SelectionBoxWidget';\r\n\r\nexport class SelectionBoxLayerFactory extends AbstractReactFactory<SelectionLayerModel> {\r\n\tconstructor() {\r\n\t\tsuper('selection');\r\n\t}\r\n\r\n\tgenerateModel(event: GenerateModelEvent): SelectionLayerModel {\r\n\t\treturn new SelectionLayerModel();\r\n\t}\r\n\r\n\tgenerateReactWidget(event: GenerateWidgetEvent<SelectionLayerModel>): JSX.Element {\r\n\t\treturn <SelectionBoxWidget rect={event.model.box} />;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport styled from '@emotion/styled';\r\nimport { SimpleClientRect } from '../../states/SelectionBoxState';\r\n\r\nexport interface SelectionBoxWidgetProps {\r\n\trect: SimpleClientRect;\r\n}\r\n\r\nnamespace S {\r\n\texport const Container = styled.div`\r\n\t\tposition: absolute;\r\n\t\tbackground-color: rgba(0, 192, 255, 0.2);\r\n\t\tborder: solid 2px rgb(0, 192, 255);\r\n\t`;\r\n}\r\n\r\nexport class SelectionBoxWidget extends React.Component<SelectionBoxWidgetProps> {\r\n\trender() {\r\n\t\tconst { rect } = this.props;\r\n\r\n\t\tif (!rect) return null;\r\n\r\n\t\treturn (\r\n\t\t\t<S.Container\r\n\t\t\t\tstyle={{\r\n\t\t\t\t\ttop: rect.top,\r\n\t\t\t\t\tleft: rect.left,\r\n\t\t\t\t\twidth: rect.width,\r\n\t\t\t\t\theight: rect.height\r\n\t\t\t\t}}\r\n\t\t\t/>\r\n\t\t);\r\n\t}\r\n}\r\n","import { LayerModel } from '../layer/LayerModel';\r\nimport { FactoryBank } from '../../core/FactoryBank';\r\nimport { AbstractModelFactory } from '../../core/AbstractModelFactory';\r\nimport { BaseModel } from '../../core-models/BaseModel';\r\nimport { SimpleClientRect } from '../../states/SelectionBoxState';\r\n\r\nexport class SelectionLayerModel extends LayerModel {\r\n\tbox: SimpleClientRect;\r\n\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\ttransformed: false,\r\n\t\t\tisSvg: false,\r\n\t\t\ttype: 'selection'\r\n\t\t});\r\n\t}\r\n\r\n\tsetBox(rect: SimpleClientRect) {\r\n\t\tthis.box = rect;\r\n\t}\r\n\r\n\tgetChildModelFactoryBank(): FactoryBank<AbstractModelFactory<BaseModel>> {\r\n\t\t// is not used as it doesnt serialize\r\n\t\treturn null;\r\n\t}\r\n}\r\n","import { State } from '../core-state/State';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\nimport { MouseEvent, TouchEvent } from 'react';\r\nimport { DragCanvasState } from './DragCanvasState';\r\nimport { SelectingState } from './SelectingState';\r\nimport { MoveItemsState } from './MoveItemsState';\r\n\r\nexport class DefaultState extends State {\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\tname: 'default'\r\n\t\t});\r\n\t\tthis.childStates = [new SelectingState()];\r\n\r\n\t\t// determine what was clicked on\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_DOWN,\r\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\r\n\t\t\t\t\tconst element = this.engine.getActionEventBus().getModelForEvent(event);\r\n\r\n\t\t\t\t\t// the canvas was clicked on, transition to the dragging canvas state\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\tthis.transitionWithEvent(new DragCanvasState(), event);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.transitionWithEvent(new MoveItemsState(), event);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\t// touch drags the canvas\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.TOUCH_START,\r\n\t\t\t\tfire: (event: ActionEvent<TouchEvent>) => {\r\n\t\t\t\t\tthis.transitionWithEvent(new DragCanvasState(), event);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n","import { CanvasEngine } from '../CanvasEngine';\r\nimport { AbstractDisplacementState, AbstractDisplacementStateEvent } from '../core-state/AbstractDisplacementState';\r\nimport { State } from '../core-state/State';\r\n\r\nexport interface DragCanvasStateOptions {\r\n\t/**\r\n\t * If enabled, the canvas is available to drag\r\n\t */\r\n\tallowDrag?: boolean;\r\n}\r\n\r\nexport class DragCanvasState<E extends CanvasEngine = CanvasEngine> extends AbstractDisplacementState<E> {\r\n\t// store this as we drag the canvas\r\n\tinitialCanvasX: number;\r\n\tinitialCanvasY: number;\r\n\tconfig: DragCanvasStateOptions;\r\n\r\n\tconstructor(options: DragCanvasStateOptions = {}) {\r\n\t\tsuper({\r\n\t\t\tname: 'drag-canvas'\r\n\t\t});\r\n\t\tthis.config = {\r\n\t\t\tallowDrag: true,\r\n\t\t\t...options\r\n\t\t};\r\n\t}\r\n\r\n\tasync activated(prev) {\r\n\t\tsuper.activated(prev);\r\n\t\tthis.engine.getModel().clearSelection();\r\n\t\tawait this.engine.repaintCanvas(true);\r\n\r\n\t\t// we can block layer rendering because we are only targeting the transforms\r\n\t\tfor (let layer of this.engine.getModel().getLayers()) {\r\n\t\t\tlayer.allowRepaint(false);\r\n\t\t}\r\n\r\n\t\tthis.initialCanvasX = this.engine.getModel().getOffsetX();\r\n\t\tthis.initialCanvasY = this.engine.getModel().getOffsetY();\r\n\t}\r\n\r\n\tdeactivated(next: State) {\r\n\t\tsuper.deactivated(next);\r\n\t\tfor (let layer of this.engine.getModel().getLayers()) {\r\n\t\t\tlayer.allowRepaint(true);\r\n\t\t}\r\n\t}\r\n\r\n\tfireMouseMoved(event: AbstractDisplacementStateEvent) {\r\n\t\tif (this.config.allowDrag) {\r\n\t\t\tthis.engine\r\n\t\t\t\t.getModel()\r\n\t\t\t\t.setOffset(this.initialCanvasX + event.displacementX, this.initialCanvasY + event.displacementY);\r\n\t\t\tthis.engine.repaintCanvas();\r\n\t\t}\r\n\t}\r\n}\r\n","import { AbstractDisplacementState, AbstractDisplacementStateEvent } from '../core-state/AbstractDisplacementState';\r\nimport { State } from '../core-state/State';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\nimport { BasePositionModel } from '../core-models/BasePositionModel';\r\nimport { Point } from '@projectstorm/geometry';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\n\r\nexport class MoveItemsState<E extends CanvasEngine = CanvasEngine> extends AbstractDisplacementState<E> {\r\n\tinitialPositions: {\r\n\t\t[id: string]: {\r\n\t\t\tpoint: Point;\r\n\t\t\titem: BasePositionModel;\r\n\t\t};\r\n\t};\r\n\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\tname: 'move-items'\r\n\t\t});\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_DOWN,\r\n\t\t\t\tfire: (event: ActionEvent<React.MouseEvent>) => {\r\n\t\t\t\t\tconst element = this.engine.getActionEventBus().getModelForEvent(event);\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!element.isSelected()) {\r\n\t\t\t\t\t\tthis.engine.getModel().clearSelection();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telement.setSelected(true);\r\n\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\tactivated(previous: State) {\r\n\t\tsuper.activated(previous);\r\n\t\tthis.initialPositions = {};\r\n\t}\r\n\r\n\tfireMouseMoved(event: AbstractDisplacementStateEvent) {\r\n\t\tconst items = this.engine.getModel().getSelectedEntities();\r\n\t\tconst model = this.engine.getModel();\r\n\t\tfor (let item of items) {\r\n\t\t\tif (item instanceof BasePositionModel) {\r\n\t\t\t\tif (item.isLocked()) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.initialPositions[item.getID()]) {\r\n\t\t\t\t\tthis.initialPositions[item.getID()] = {\r\n\t\t\t\t\t\tpoint: item.getPosition(),\r\n\t\t\t\t\t\titem: item\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst pos = this.initialPositions[item.getID()].point;\r\n\t\t\t\titem.setPosition(\r\n\t\t\t\t\tmodel.getGridPosition(pos.x + event.virtualDisplacementX),\r\n\t\t\t\t\tmodel.getGridPosition(pos.y + event.virtualDisplacementY)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.engine.repaintCanvas();\r\n\t}\r\n}\r\n","import { State } from '../core-state/State';\r\nimport { Action, ActionEvent, InputType } from '../core-actions/Action';\r\nimport { SelectionBoxState } from './SelectionBoxState';\r\nimport { MouseEvent } from 'react';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\n\r\nexport class SelectingState<E extends CanvasEngine = CanvasEngine> extends State<E> {\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\tname: 'selecting'\r\n\t\t});\r\n\t\tthis.keys = ['shift'];\r\n\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_DOWN,\r\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\r\n\t\t\t\t\tconst element = this.engine.getActionEventBus().getModelForEvent(event);\r\n\r\n\t\t\t\t\t// go into a selection box on the canvas state\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\tthis.transitionWithEvent(new SelectionBoxState(), event);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telement.setSelected(true);\r\n\t\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n","import { AbstractDisplacementState, AbstractDisplacementStateEvent } from '../core-state/AbstractDisplacementState';\r\nimport { State } from '../core-state/State';\r\nimport { SelectionLayerModel } from '../entities/selection/SelectionLayerModel';\r\nimport { Point, Rectangle } from '@projectstorm/geometry';\r\nimport { BasePositionModel } from '../core-models/BasePositionModel';\r\nimport { ModelGeometryInterface } from '../core/ModelGeometryInterface';\r\nimport { CanvasEngine } from '../CanvasEngine';\r\n\r\nexport interface SimpleClientRect {\r\n\tleft: number;\r\n\tright: number;\r\n\twidth: number;\r\n\theight: number;\r\n\ttop: number;\r\n\tbottom: number;\r\n}\r\n\r\nexport class SelectionBoxState<E extends CanvasEngine = CanvasEngine> extends AbstractDisplacementState<E> {\r\n\tlayer: SelectionLayerModel;\r\n\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\tname: 'selection-box'\r\n\t\t});\r\n\t}\r\n\r\n\tactivated(previous: State) {\r\n\t\tsuper.activated(previous);\r\n\t\tthis.layer = new SelectionLayerModel();\r\n\t\tthis.engine.getModel().addLayer(this.layer);\r\n\t}\r\n\r\n\tdeactivated(next: State) {\r\n\t\tsuper.deactivated(next);\r\n\t\tthis.layer.remove();\r\n\t\tthis.engine.repaintCanvas();\r\n\t}\r\n\r\n\tgetBoxDimensions(event: AbstractDisplacementStateEvent): SimpleClientRect {\r\n\t\tlet rel: Point;\r\n\r\n\t\tif ('touches' in event.event) {\r\n\t\t\tconst touch = event.event.touches[0];\r\n\t\t\trel = this.engine.getRelativePoint(touch.clientX, touch.clientY);\r\n\t\t} else {\r\n\t\t\trel = this.engine.getRelativePoint(event.event.clientX, event.event.clientY);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tleft: rel.x > this.initialXRelative ? this.initialXRelative : rel.x,\r\n\t\t\ttop: rel.y > this.initialYRelative ? this.initialYRelative : rel.y,\r\n\t\t\twidth: Math.abs(rel.x - this.initialXRelative),\r\n\t\t\theight: Math.abs(rel.y - this.initialYRelative),\r\n\t\t\tright: rel.x < this.initialXRelative ? this.initialXRelative : rel.x,\r\n\t\t\tbottom: rel.y < this.initialYRelative ? this.initialYRelative : rel.y\r\n\t\t};\r\n\t}\r\n\r\n\tfireMouseMoved(event: AbstractDisplacementStateEvent) {\r\n\t\tthis.layer.setBox(this.getBoxDimensions(event));\r\n\r\n\t\tconst relative = this.engine.getRelativeMousePoint({\r\n\t\t\tclientX: this.initialX,\r\n\t\t\tclientY: this.initialY\r\n\t\t});\r\n\t\tif (event.virtualDisplacementX < 0) {\r\n\t\t\trelative.x -= Math.abs(event.virtualDisplacementX);\r\n\t\t}\r\n\t\tif (event.virtualDisplacementY < 0) {\r\n\t\t\trelative.y -= Math.abs(event.virtualDisplacementY);\r\n\t\t}\r\n\t\tconst rect = Rectangle.fromPointAndSize(\r\n\t\t\trelative,\r\n\t\t\tMath.abs(event.virtualDisplacementX),\r\n\t\t\tMath.abs(event.virtualDisplacementY)\r\n\t\t);\r\n\r\n\t\tfor (let model of this.engine.getModel().getSelectionEntities()) {\r\n\t\t\tif ((model as unknown as ModelGeometryInterface).getBoundingBox) {\r\n\t\t\t\tconst bounds = (model as unknown as ModelGeometryInterface).getBoundingBox();\r\n\t\t\t\tif (rect.containsPoint(bounds.getTopLeft()) && rect.containsPoint(bounds.getBottomRight())) {\r\n\t\t\t\t\tmodel.setSelected(true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmodel.setSelected(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.engine.repaintCanvas();\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport _isEqual from 'lodash/isEqual';\r\nimport { BaseModel } from '../core-models/BaseModel';\r\n\r\nexport interface PeformanceWidgetProps {\r\n\tchildren: () => JSX.Element;\r\n\tserialized: object;\r\n\tmodel: BaseModel;\r\n}\r\n\r\nexport interface PeformanceWidgetState {}\r\n\r\nexport class PeformanceWidget extends React.Component<PeformanceWidgetProps, PeformanceWidgetState> {\r\n\tshouldComponentUpdate(\r\n\t\tnextProps: Readonly<PeformanceWidgetProps>,\r\n\t\tnextState: Readonly<PeformanceWidgetState>,\r\n\t\tnextContext: any\r\n\t): boolean {\r\n\t\tif (!this.props.model.performanceTune()) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// deserialization event\r\n\t\tif (this.props.model !== nextProps.model) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// change event\r\n\t\treturn !_isEqual(this.props.serialized, nextProps.serialized);\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn this.props.children();\r\n\t}\r\n}\r\n","module.exports = require(\"@emotion/react\");","module.exports = require(\"@emotion/styled\");","module.exports = require(\"@projectstorm/geometry\");","module.exports = require(\"lodash/cloneDeep\");","module.exports = require(\"lodash/debounce\");","module.exports = require(\"lodash/filter\");","module.exports = require(\"lodash/flatMap\");","module.exports = require(\"lodash/forEach\");","module.exports = require(\"lodash/intersection\");","module.exports = require(\"lodash/isEqual\");","module.exports = require(\"lodash/keys\");","module.exports = require(\"lodash/last\");","module.exports = require(\"lodash/map\");","module.exports = require(\"lodash/mapValues\");","module.exports = require(\"lodash/values\");","module.exports = require(\"react\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * from './CanvasEngine';\r\nexport * from './Toolkit';\r\nexport * from './entities/canvas/CanvasModel';\r\n\r\nexport * from './core/AbstractFactory';\r\nexport * from './core/AbstractModelFactory';\r\nexport * from './core/AbstractReactFactory';\r\nexport * from './core/BaseObserver';\r\nexport * from './core/FactoryBank';\r\nexport * from './core/ModelGeometryInterface';\r\n\r\nexport * from './core-actions/Action';\r\nexport * from './core-actions/ActionEventBus';\r\n\r\nexport * from './core-models/BaseEntity';\r\nexport * from './core-models/BaseModel';\r\nexport * from './core-models/BasePositionModel';\r\n\r\nexport * from './entities/canvas/CanvasModel';\r\nexport * from './entities/canvas/CanvasWidget';\r\n\r\nexport * from './entities/layer/LayerModel';\r\nexport * from './entities/layer/TransformLayerWidget';\r\nexport * from './entities/layer/SmartLayerWidget';\r\n\r\nexport * from './entities/selection/SelectionBoxLayerFactory';\r\nexport * from './entities/selection/SelectionBoxWidget';\r\nexport * from './entities/selection/SelectionLayerModel';\r\n\r\nexport * from './widgets/PeformanceWidget';\r\n\r\nexport * from './core-state/AbstractDisplacementState';\r\nexport * from './core-state/State';\r\nexport * from './core-state/StateMachine';\r\n\r\nexport * from './states/DefaultState';\r\nexport * from './states/DragCanvasState';\r\nexport * from './states/SelectingState';\r\nexport * from './states/SelectionBoxState';\r\nexport * from './states/MoveItemsState';\r\n\r\nexport * from './actions/DeleteItemsAction';\r\nexport * from './actions/ZoomCanvasAction';\r\nexport * from './actions/PanAndZoomCanvasAction';\r\n"],"names":[],"sourceRoot":""}