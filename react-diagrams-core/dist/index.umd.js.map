{"version":3,"file":"index.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVA;AAIA;AAEA;AAYA;;AAEA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5SA;AAYA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;ACnCA;AAGA;AAQA;AAAA;AACA;;;AAGA;AAEA;;;AAGA;AACA;AAEA;AAGA;AACA;AAYA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AA1DA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAmDA;AACA;AAEA;AAEA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AASA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AAIA;AACA;AAoBA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3TA;AAIA;AACA;AACA;AAaA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAQA;AAGA;AAGA;AACA;;;;;;;;;;;;;;;;;AC5HA;AAiBA;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AAEA;AASA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AAIA;AACA;AAkBA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC/JA;AACA;AAGA;AACA;AACA;AAQA;AAAA;AACA;;;;;;;AAOA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAMA;AACA;AACA;AAKA;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAAA;AACA;AACA;AACA;AACA;AACA;AAqBA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACvKA;AACA;AAGA;AASA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AAYA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtKA;AAQA;AACA;AAEA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;ACrCA;AAOA;AAiBA;AAKA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;AC5GA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA","sources":["webpack://projectstorm/react-canvas-core/webpack/universalModuleDefinition","webpack://projectstorm/react-canvas-core/./src/DiagramEngine.ts","webpack://projectstorm/react-canvas-core/./src/entities/label/LabelModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/label/LabelWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/link-layer/LinkLayerFactory.tsx","webpack://projectstorm/react-canvas-core/./src/entities/link-layer/LinkLayerModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/link-layer/LinkLayerWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/link/LinkModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/link/LinkWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/link/PointModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/node-layer/NodeLayerFactory.tsx","webpack://projectstorm/react-canvas-core/./src/entities/node-layer/NodeLayerModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/node-layer/NodeLayerWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/node/NodeModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/node/NodeWidget.tsx","webpack://projectstorm/react-canvas-core/./src/entities/port/PortModel.ts","webpack://projectstorm/react-canvas-core/./src/entities/port/PortWidget.tsx","webpack://projectstorm/react-canvas-core/./src/models/DiagramModel.ts","webpack://projectstorm/react-canvas-core/./src/states/DefaultDiagramState.ts","webpack://projectstorm/react-canvas-core/./src/states/DragDiagramItemsState.ts","webpack://projectstorm/react-canvas-core/./src/states/DragNewLinkState.ts","webpack://projectstorm/react-canvas-core/external commonjs \"@emotion/styled\"","webpack://projectstorm/react-canvas-core/external commonjs \"@projectstorm/geometry\"","webpack://projectstorm/react-canvas-core/external commonjs \"@projectstorm/react-canvas-core\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/filter\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/flatMap\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/forEach\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/isFinite\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/keys\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/map\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/size\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/slice\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/some\"","webpack://projectstorm/react-canvas-core/external commonjs \"lodash/values\"","webpack://projectstorm/react-canvas-core/external commonjs \"react\"","webpack://projectstorm/react-canvas-core/external commonjs \"resize-observer-polyfill\"","webpack://projectstorm/react-canvas-core/webpack/bootstrap","webpack://projectstorm/react-canvas-core/webpack/runtime/compat get default export","webpack://projectstorm/react-canvas-core/webpack/runtime/define property getters","webpack://projectstorm/react-canvas-core/webpack/runtime/hasOwnProperty shorthand","webpack://projectstorm/react-canvas-core/webpack/runtime/make namespace object","webpack://projectstorm/react-canvas-core/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"projectstorm/react-canvas-core\"] = factory();\n\telse\n\t\troot[\"projectstorm/react-canvas-core\"] = factory();\n})(self, () => {\nreturn ","import { NodeModel } from './entities/node/NodeModel';\r\nimport { PortModel } from './entities/port/PortModel';\r\nimport { LinkModel } from './entities/link/LinkModel';\r\nimport { LabelModel } from './entities/label/LabelModel';\r\nimport { boundingBoxFromPolygons, Point, Rectangle } from '@projectstorm/geometry';\r\nimport { MouseEvent } from 'react';\r\nimport {\r\n\tAbstractModelFactory,\r\n\tAbstractReactFactory,\r\n\tBaseModel,\r\n\tCanvasEngine,\r\n\tCanvasEngineListener,\r\n\tCanvasEngineOptions,\r\n\tFactoryBank,\r\n\tToolkit\r\n} from '@projectstorm/react-canvas-core';\r\nimport { DiagramModel } from './models/DiagramModel';\r\n\r\n/**\r\n * Passed as a parameter to the DiagramWidget\r\n */\r\nexport class DiagramEngine extends CanvasEngine<CanvasEngineListener, DiagramModel> {\r\n\tprotected nodeFactories: FactoryBank<AbstractReactFactory<NodeModel, DiagramEngine>>;\r\n\tprotected linkFactories: FactoryBank<AbstractReactFactory<LinkModel, DiagramEngine>>;\r\n\tprotected portFactories: FactoryBank<AbstractModelFactory<PortModel, DiagramEngine>>;\r\n\tprotected labelFactories: FactoryBank<AbstractReactFactory<LabelModel, DiagramEngine>>;\r\n\r\n\tmaxNumberPointsPerLink: number;\r\n\r\n\tconstructor(options: CanvasEngineOptions = {}) {\r\n\t\tsuper(options);\r\n\t\tthis.maxNumberPointsPerLink = 1000;\r\n\r\n\t\t// create banks for the different factory types\r\n\t\tthis.nodeFactories = new FactoryBank();\r\n\t\tthis.linkFactories = new FactoryBank();\r\n\t\tthis.portFactories = new FactoryBank();\r\n\t\tthis.labelFactories = new FactoryBank();\r\n\r\n\t\tconst setup = (factory: FactoryBank) => {\r\n\t\t\tfactory.registerListener({\r\n\t\t\t\tfactoryAdded: (event) => {\r\n\t\t\t\t\tevent.factory.setDiagramEngine(this);\r\n\t\t\t\t},\r\n\t\t\t\tfactoryRemoved: (event) => {\r\n\t\t\t\t\tevent.factory.setDiagramEngine(null);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tsetup(this.nodeFactories);\r\n\t\tsetup(this.linkFactories);\r\n\t\tsetup(this.portFactories);\r\n\t\tsetup(this.labelFactories);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a model and element under the mouse cursor\r\n\t */\r\n\tgetMouseElement(event: MouseEvent): BaseModel {\r\n\t\tvar target = event.target as Element;\r\n\t\tvar diagramModel = this.model;\r\n\r\n\t\t//is it a port\r\n\t\tvar element = Toolkit.closest(target, '.port[data-name]');\r\n\t\tif (element) {\r\n\t\t\tvar nodeElement = Toolkit.closest(target, '.node[data-nodeid]') as HTMLElement;\r\n\t\t\treturn diagramModel.getNode(nodeElement.getAttribute('data-nodeid')).getPort(element.getAttribute('data-name'));\r\n\t\t}\r\n\r\n\t\t//look for a point\r\n\t\telement = Toolkit.closest(target, '.point[data-id]');\r\n\t\tif (element) {\r\n\t\t\treturn diagramModel.getLink(element.getAttribute('data-linkid')).getPointModel(element.getAttribute('data-id'));\r\n\t\t}\r\n\r\n\t\t//look for a link\r\n\t\telement = Toolkit.closest(target, '[data-linkid]');\r\n\t\tif (element) {\r\n\t\t\treturn diagramModel.getLink(element.getAttribute('data-linkid'));\r\n\t\t}\r\n\r\n\t\t//look for a node\r\n\t\telement = Toolkit.closest(target, '.node[data-nodeid]');\r\n\t\tif (element) {\r\n\t\t\treturn diagramModel.getNode(element.getAttribute('data-nodeid'));\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\t//!-------------- FACTORIES ------------\r\n\r\n\tgetNodeFactories() {\r\n\t\treturn this.nodeFactories;\r\n\t}\r\n\r\n\tgetLinkFactories() {\r\n\t\treturn this.linkFactories;\r\n\t}\r\n\r\n\tgetLabelFactories() {\r\n\t\treturn this.labelFactories;\r\n\t}\r\n\r\n\tgetPortFactories() {\r\n\t\treturn this.portFactories;\r\n\t}\r\n\r\n\tgetFactoryForNode<F extends AbstractReactFactory<NodeModel, DiagramEngine>>(node: NodeModel | string) {\r\n\t\tif (typeof node === 'string') {\r\n\t\t\treturn this.nodeFactories.getFactory(node);\r\n\t\t}\r\n\t\treturn this.nodeFactories.getFactory(node.getType());\r\n\t}\r\n\r\n\tgetFactoryForLink<F extends AbstractReactFactory<LinkModel, DiagramEngine>>(link: LinkModel | string) {\r\n\t\tif (typeof link === 'string') {\r\n\t\t\treturn this.linkFactories.getFactory<F>(link);\r\n\t\t}\r\n\t\treturn this.linkFactories.getFactory<F>(link.getType());\r\n\t}\r\n\r\n\tgetFactoryForLabel<F extends AbstractReactFactory<LabelModel, DiagramEngine>>(label: LabelModel) {\r\n\t\tif (typeof label === 'string') {\r\n\t\t\treturn this.labelFactories.getFactory(label);\r\n\t\t}\r\n\t\treturn this.labelFactories.getFactory(label.getType());\r\n\t}\r\n\r\n\tgetFactoryForPort<F extends AbstractModelFactory<PortModel, DiagramEngine>>(port: PortModel) {\r\n\t\tif (typeof port === 'string') {\r\n\t\t\treturn this.portFactories.getFactory<F>(port);\r\n\t\t}\r\n\t\treturn this.portFactories.getFactory<F>(port.getType());\r\n\t}\r\n\r\n\tgenerateWidgetForLink(link: LinkModel): JSX.Element {\r\n\t\treturn this.getFactoryForLink(link).generateReactWidget({ model: link });\r\n\t}\r\n\r\n\tgenerateWidgetForNode(node: NodeModel): JSX.Element {\r\n\t\treturn this.getFactoryForNode(node).generateReactWidget({ model: node });\r\n\t}\r\n\r\n\tgetNodeElement(node: NodeModel): Element {\r\n\t\tconst selector = this.canvas.querySelector(`.node[data-nodeid=\"${node.getID()}\"]`);\r\n\t\tif (selector === null) {\r\n\t\t\tthrow new Error('Cannot find Node element with nodeID: [' + node.getID() + ']');\r\n\t\t}\r\n\t\treturn selector;\r\n\t}\r\n\r\n\tgetNodePortElement(port: PortModel): any {\r\n\t\tvar selector = this.canvas.querySelector(\r\n\t\t\t`.port[data-name=\"${port.getName()}\"][data-nodeid=\"${port.getParent().getID()}\"]`\r\n\t\t);\r\n\t\tif (selector === null) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Cannot find Node Port element with nodeID: [' +\r\n\t\t\t\t\tport.getParent().getID() +\r\n\t\t\t\t\t'] and name: [' +\r\n\t\t\t\t\tport.getName() +\r\n\t\t\t\t\t']'\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn selector;\r\n\t}\r\n\r\n\tgetPortCenter(port: PortModel): Point {\r\n\t\treturn this.getPortCoords(port).getOrigin();\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate rectangular coordinates of the port passed in.\r\n\t */\r\n\tgetPortCoords(port: PortModel, element?: HTMLDivElement): Rectangle {\r\n\t\tif (!this.canvas) {\r\n\t\t\tthrow new Error('Canvas needs to be set first');\r\n\t\t}\r\n\t\tif (!element) {\r\n\t\t\telement = this.getNodePortElement(port);\r\n\t\t}\r\n\t\tconst sourceRect = element.getBoundingClientRect();\r\n\t\tconst point = this.getRelativeMousePoint({\r\n\t\t\tclientX: sourceRect.left,\r\n\t\t\tclientY: sourceRect.top\r\n\t\t});\r\n\t\tconst zoom = this.model.getZoomLevel() / 100.0;\r\n\t\treturn Rectangle.fromPointAndSize(point, sourceRect.width / zoom, sourceRect.height / zoom);\r\n\t}\r\n\r\n\t/**\r\n\t * Determine the width and height of the node passed in.\r\n\t * It currently assumes nodes have a rectangular shape, can be overriden for customised shapes.\r\n\t */\r\n\tgetNodeDimensions(node: NodeModel): { width: number; height: number } {\r\n\t\tif (!this.canvas) {\r\n\t\t\treturn {\r\n\t\t\t\twidth: 0,\r\n\t\t\t\theight: 0\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tconst nodeElement = this.getNodeElement(node);\r\n\t\tconst nodeRect = nodeElement.getBoundingClientRect();\r\n\r\n\t\treturn {\r\n\t\t\twidth: nodeRect.width,\r\n\t\t\theight: nodeRect.height\r\n\t\t};\r\n\t}\r\n\r\n\tgetBoundingNodesRect(nodes: NodeModel[]): Rectangle {\r\n\t\tif (nodes) {\r\n\t\t\tif (nodes.length === 0) {\r\n\t\t\t\treturn new Rectangle();\r\n\t\t\t}\r\n\t\t\treturn new Rectangle(boundingBoxFromPolygons(nodes.map((node) => node.getBoundingBox())));\r\n\t\t}\r\n\t}\r\n\r\n\tzoomToFitSelectedNodes(options: { margin?: number; maxZoom?: number }) {\r\n\t\tconst nodes: NodeModel[] = this.model\r\n\t\t\t.getSelectedEntities()\r\n\t\t\t.filter((entity) => entity instanceof NodeModel) as NodeModel[];\r\n\t\tthis.zoomToFitNodes({\r\n\t\t\tmargin: options.margin,\r\n\t\t\tmaxZoom: options.maxZoom,\r\n\t\t\tnodes: nodes.length > 0 ? nodes : null\r\n\t\t});\r\n\t}\r\n\r\n\tzoomToFitNodes(options: { margin?: number; nodes?: NodeModel[]; maxZoom?: number });\r\n\t/**\r\n\t * @deprecated\r\n\t */\r\n\tzoomToFitNodes(margin: number);\r\n\tzoomToFitNodes(options) {\r\n\t\tlet margin = options || 0;\r\n\t\tlet nodes: NodeModel[] = [];\r\n\t\tlet maxZoom: number | null = null;\r\n\t\tif (!!options && typeof options == 'object') {\r\n\t\t\tmargin = options.margin || 0;\r\n\t\t\tnodes = options.nodes || [];\r\n\t\t\tmaxZoom = options.maxZoom || null;\r\n\t\t}\r\n\r\n\t\t// no node selected\r\n\t\tif (nodes.length === 0) {\r\n\t\t\tnodes = this.model.getNodes();\r\n\t\t}\r\n\t\tconst nodesRect = this.getBoundingNodesRect(nodes);\r\n\t\tif (nodesRect) {\r\n\t\t\t// there is something we should zoom on\r\n\t\t\tlet canvasRect = this.canvas.getBoundingClientRect();\r\n\r\n\t\t\tconst calculate = (margin: number = 0) => {\r\n\t\t\t\t// work out zoom\r\n\t\t\t\tconst xFactor = this.canvas.clientWidth / (nodesRect.getWidth() + margin * 2);\r\n\t\t\t\tconst yFactor = this.canvas.clientHeight / (nodesRect.getHeight() + margin * 2);\r\n\r\n\t\t\t\tlet zoomFactor = xFactor < yFactor ? xFactor : yFactor;\r\n\t\t\t\tif (maxZoom && zoomFactor > maxZoom) {\r\n\t\t\t\t\tzoomFactor = maxZoom;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tzoom: zoomFactor,\r\n\t\t\t\t\tx:\r\n\t\t\t\t\t\tcanvasRect.width / 2 -\r\n\t\t\t\t\t\t((nodesRect.getWidth() + margin * 2) / 2 + nodesRect.getTopLeft().x) * zoomFactor +\r\n\t\t\t\t\t\tmargin,\r\n\t\t\t\t\ty:\r\n\t\t\t\t\t\tcanvasRect.height / 2 -\r\n\t\t\t\t\t\t((nodesRect.getHeight() + margin * 2) / 2 + nodesRect.getTopLeft().y) * zoomFactor +\r\n\t\t\t\t\t\tmargin\r\n\t\t\t\t};\r\n\t\t\t};\r\n\r\n\t\t\tlet params = calculate(0);\r\n\t\t\tif (margin) {\r\n\t\t\t\tif (params.x < margin || params.y < margin) {\r\n\t\t\t\t\tparams = calculate(margin);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// apply\r\n\t\t\tthis.model.setZoomLevel(params.zoom * 100);\r\n\t\t\tthis.model.setOffset(params.x, params.y);\r\n\t\t\tthis.repaintCanvas();\r\n\t\t}\r\n\t}\r\n\r\n\tgetMaxNumberPointsPerLink(): number {\r\n\t\treturn this.maxNumberPointsPerLink;\r\n\t}\r\n\r\n\tsetMaxNumberPointsPerLink(max: number) {\r\n\t\tthis.maxNumberPointsPerLink = max;\r\n\t}\r\n}\r\n","import { LinkModel } from '../link/LinkModel';\r\nimport { BaseModel, BaseModelGenerics, BaseModelOptions, DeserializeEvent } from '@projectstorm/react-canvas-core';\r\n\r\nexport interface LabelModelOptions extends BaseModelOptions {\r\n\toffsetX?: number;\r\n\toffsetY?: number;\r\n}\r\n\r\nexport interface LabelModelGenerics extends BaseModelGenerics {\r\n\tPARENT: LinkModel;\r\n\tOPTIONS: LabelModelOptions;\r\n}\r\n\r\nexport class LabelModel<G extends LabelModelGenerics = LabelModelGenerics> extends BaseModel<G> {\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper({\r\n\t\t\t...options,\r\n\t\t\toffsetX: options.offsetX || 0,\r\n\t\t\toffsetY: options.offsetY || 0\r\n\t\t});\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.options.offsetX = event.data.offsetX;\r\n\t\tthis.options.offsetY = event.data.offsetY;\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\toffsetX: this.options.offsetX,\r\n\t\t\toffsetY: this.options.offsetY\r\n\t\t};\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { LabelModel } from './LabelModel';\r\nimport styled from '@emotion/styled';\r\n\r\nexport interface LabelWidgetProps {\r\n\tengine: DiagramEngine;\r\n\tlabel: LabelModel;\r\n\tindex: number;\r\n}\r\n\r\nnamespace S {\r\n\texport const Label = styled.div`\r\n\t\tdisplay: inline-block;\r\n\t\tposition: absolute;\r\n\t`;\r\n\r\n\texport const Foreign = styled.foreignObject`\r\n\t\tpointer-events: none;\r\n\t\toverflow: visible;\r\n\t`;\r\n}\r\n\r\nexport class LabelWidget extends React.Component<LabelWidgetProps> {\r\n\tref: React.RefObject<HTMLDivElement>;\r\n\r\n\tconstructor(props: LabelWidgetProps) {\r\n\t\tsuper(props);\r\n\t\tthis.ref = React.createRef();\r\n\t}\r\n\r\n\tcomponentDidUpdate() {\r\n\t\twindow.requestAnimationFrame(this.calculateLabelPosition);\r\n\t}\r\n\r\n\tcomponentDidMount() {\r\n\t\twindow.requestAnimationFrame(this.calculateLabelPosition);\r\n\t}\r\n\r\n\tfindPathAndRelativePositionToRenderLabel = (index: number): { path: SVGPathElement; position: number } => {\r\n\t\t// an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\r\n\t\tconst link = this.props.label.getParent();\r\n\t\tconst lengths = link.getRenderedPath().map((path) => path.getTotalLength());\r\n\r\n\t\t// calculate the point where we want to display the label\r\n\t\tlet labelPosition =\r\n\t\t\tlengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) *\r\n\t\t\t(index / (link.getLabels().length + 1));\r\n\r\n\t\t// find the path where the label will be rendered and calculate the relative position\r\n\t\tlet pathIndex = 0;\r\n\t\twhile (pathIndex < link.getRenderedPath().length) {\r\n\t\t\tif (labelPosition - lengths[pathIndex] < 0) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpath: link.getRenderedPath()[pathIndex],\r\n\t\t\t\t\tposition: labelPosition\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// keep searching\r\n\t\t\tlabelPosition -= lengths[pathIndex];\r\n\t\t\tpathIndex++;\r\n\t\t}\r\n\t};\r\n\r\n\tcalculateLabelPosition = () => {\r\n\t\tconst found = this.findPathAndRelativePositionToRenderLabel(this.props.index + 1);\r\n\t\tif (!found) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst { path, position } = found;\r\n\r\n\t\tconst labelDimensions = {\r\n\t\t\twidth: this.ref.current.offsetWidth,\r\n\t\t\theight: this.ref.current.offsetHeight\r\n\t\t};\r\n\r\n\t\tconst pathCentre = path.getPointAtLength(position);\r\n\r\n\t\tconst labelCoordinates = {\r\n\t\t\tx: pathCentre.x - labelDimensions.width / 2 + this.props.label.getOptions().offsetX,\r\n\t\t\ty: pathCentre.y - labelDimensions.height / 2 + this.props.label.getOptions().offsetY\r\n\t\t};\r\n\r\n\t\tthis.ref.current.style.transform = `translate(${labelCoordinates.x}px, ${labelCoordinates.y}px)`;\r\n\t};\r\n\r\n\trender() {\r\n\t\tconst canvas = this.props.engine.getCanvas();\r\n\r\n\t\treturn (\r\n\t\t\t<S.Foreign key={this.props.label.getID()} width={canvas?.offsetWidth} height={canvas?.offsetHeight}>\r\n\t\t\t\t<S.Label ref={this.ref}>\r\n\t\t\t\t\t{this.props.engine.getFactoryForLabel(this.props.label).generateReactWidget({ model: this.props.label })}\r\n\t\t\t\t</S.Label>\r\n\t\t\t</S.Foreign>\r\n\t\t);\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { AbstractReactFactory, GenerateModelEvent, GenerateWidgetEvent } from '@projectstorm/react-canvas-core';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { LinkLayerModel } from './LinkLayerModel';\r\nimport { LinkLayerWidget } from './LinkLayerWidget';\r\n\r\nexport class LinkLayerFactory extends AbstractReactFactory<LinkLayerModel, DiagramEngine> {\r\n\tconstructor() {\r\n\t\tsuper('diagram-links');\r\n\t}\r\n\r\n\tgenerateModel(event: GenerateModelEvent): LinkLayerModel {\r\n\t\treturn new LinkLayerModel();\r\n\t}\r\n\r\n\tgenerateReactWidget(event: GenerateWidgetEvent<LinkLayerModel>): JSX.Element {\r\n\t\treturn <LinkLayerWidget layer={event.model} engine={this.engine} />;\r\n\t}\r\n}\r\n","import { LayerModel, LayerModelGenerics } from '@projectstorm/react-canvas-core';\r\nimport { LinkModel } from '../link/LinkModel';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { DiagramModel } from '../../models/DiagramModel';\r\n\r\nexport interface LinkLayerModelGenerics extends LayerModelGenerics {\r\n\tCHILDREN: LinkModel;\r\n\tENGINE: DiagramEngine;\r\n}\r\n\r\nexport class LinkLayerModel<G extends LinkLayerModelGenerics = LinkLayerModelGenerics> extends LayerModel<G> {\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\ttype: 'diagram-links',\r\n\t\t\tisSvg: true,\r\n\t\t\ttransformed: true\r\n\t\t});\r\n\t}\r\n\r\n\taddModel(model: G['CHILDREN']): void {\r\n\t\tif (!(model instanceof LinkModel)) {\r\n\t\t\tthrow new Error('Can only add links to this layer');\r\n\t\t}\r\n\t\tmodel.registerListener({\r\n\t\t\tentityRemoved: () => {\r\n\t\t\t\t(this.getParent() as DiagramModel).removeLink(model);\r\n\t\t\t}\r\n\t\t});\r\n\t\tsuper.addModel(model);\r\n\t}\r\n\r\n\tgetLinks() {\r\n\t\treturn this.getModels();\r\n\t}\r\n\r\n\tgetChildModelFactoryBank(engine: G['ENGINE']) {\r\n\t\treturn engine.getLinkFactories();\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport styled from '@emotion/styled';\r\nimport _map from 'lodash/map';\r\nimport { LinkWidget } from '../link/LinkWidget';\r\nimport { LinkLayerModel } from './LinkLayerModel';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\n\r\nexport interface LinkLayerWidgetProps {\r\n\tlayer: LinkLayerModel;\r\n\tengine: DiagramEngine;\r\n}\r\n\r\nnamespace S {\r\n\texport const Container = styled.div``;\r\n}\r\n\r\nexport class LinkLayerWidget extends React.Component<LinkLayerWidgetProps> {\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<>\r\n\t\t\t\t{\r\n\t\t\t\t\t//only perform these actions when we have a diagram\r\n\t\t\t\t\t_map(this.props.layer.getLinks(), (link) => {\r\n\t\t\t\t\t\treturn <LinkWidget key={link.getID()} link={link} diagramEngine={this.props.engine} />;\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t</>\r\n\t\t);\r\n\t}\r\n}\r\n","import { PortModel } from '../port/PortModel';\r\nimport { PointModel } from './PointModel';\r\nimport _forEach from 'lodash/forEach';\r\nimport _map from 'lodash/map';\r\nimport _slice from 'lodash/slice';\r\nimport { LabelModel } from '../label/LabelModel';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { DiagramModel } from '../../models/DiagramModel';\r\nimport { boundingBoxFromPoints, Point, Rectangle } from '@projectstorm/geometry';\r\nimport {\r\n\tBaseEntityEvent,\r\n\tBaseModel,\r\n\tBaseModelGenerics,\r\n\tBaseModelListener,\r\n\tDeserializeEvent,\r\n\tModelGeometryInterface\r\n} from '@projectstorm/react-canvas-core';\r\n\r\nexport interface LinkModelListener extends BaseModelListener {\r\n\tsourcePortChanged?(event: BaseEntityEvent<LinkModel> & { port: null | PortModel }): void;\r\n\r\n\ttargetPortChanged?(event: BaseEntityEvent<LinkModel> & { port: null | PortModel }): void;\r\n}\r\n\r\nexport interface LinkModelGenerics extends BaseModelGenerics {\r\n\tLISTENER: LinkModelListener;\r\n\tPARENT: DiagramModel;\r\n}\r\n\r\nexport class LinkModel<G extends LinkModelGenerics = LinkModelGenerics>\r\n\textends BaseModel<G>\r\n\timplements ModelGeometryInterface\r\n{\r\n\tprotected sourcePort: PortModel | null;\r\n\tprotected targetPort: PortModel | null;\r\n\r\n\tprotected labels: LabelModel[];\r\n\tprotected points: PointModel[];\r\n\r\n\tprotected renderedPaths: SVGPathElement[];\r\n\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper(options);\r\n\t\tthis.points = [\r\n\t\t\tnew PointModel({\r\n\t\t\t\tlink: this\r\n\t\t\t}),\r\n\t\t\tnew PointModel({\r\n\t\t\t\tlink: this\r\n\t\t\t})\r\n\t\t];\r\n\t\tthis.sourcePort = null;\r\n\t\tthis.targetPort = null;\r\n\t\tthis.renderedPaths = [];\r\n\t\tthis.labels = [];\r\n\t}\r\n\r\n\tgetBoundingBox(): Rectangle {\r\n\t\treturn new Rectangle(\r\n\t\t\tboundingBoxFromPoints(\r\n\t\t\t\t_map(this.points, (point: PointModel) => {\r\n\t\t\t\t\treturn point.getPosition();\r\n\t\t\t\t})\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tgetSelectionEntities(): Array<BaseModel> {\r\n\t\tif (this.getTargetPort() && this.getSourcePort()) {\r\n\t\t\treturn super.getSelectionEntities().concat(_slice(this.points, 1, this.points.length - 1));\r\n\t\t}\r\n\t\t// allow selection of the first point\r\n\t\tif (!this.getSourcePort()) {\r\n\t\t\treturn super.getSelectionEntities().concat(_slice(this.points, 0, this.points.length - 1));\r\n\t\t}\r\n\t\t// allow selection of the last point\r\n\t\tif (!this.getTargetPort()) {\r\n\t\t\treturn super.getSelectionEntities().concat(_slice(this.points, 1, this.points.length));\r\n\t\t}\r\n\t\treturn super.getSelectionEntities().concat(this.points);\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.points = _map(event.data.points || [], (point) => {\r\n\t\t\tvar p = new PointModel({\r\n\t\t\t\tlink: this,\r\n\t\t\t\tposition: new Point(point.x, point.y)\r\n\t\t\t});\r\n\t\t\tp.deserialize({\r\n\t\t\t\t...event,\r\n\t\t\t\tdata: point\r\n\t\t\t});\r\n\t\t\treturn p;\r\n\t\t});\r\n\r\n\t\t//deserialize labels\r\n\t\t_forEach(event.data.labels || [], (label: any) => {\r\n\t\t\tlet labelOb = (event.engine as DiagramEngine).getFactoryForLabel(label.type).generateModel({});\r\n\t\t\tlabelOb.deserialize({\r\n\t\t\t\t...event,\r\n\t\t\t\tdata: label\r\n\t\t\t});\r\n\t\t\tthis.addLabel(labelOb);\r\n\t\t});\r\n\r\n\t\t// these happen async, so we use the promises for these (they need to be done like this without the async keyword\r\n\t\t// because we need the deserailize method to finish for other methods while this happen\r\n\t\tif (event.data.target) {\r\n\t\t\tevent.getModel(event.data.targetPort).then((model: PortModel) => {\r\n\t\t\t\tthis.setTargetPort(model);\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (event.data.source) {\r\n\t\t\tevent.getModel(event.data.sourcePort).then((model: PortModel) => {\r\n\t\t\t\tthis.setSourcePort(model);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tgetRenderedPath(): SVGPathElement[] {\r\n\t\treturn this.renderedPaths;\r\n\t}\r\n\r\n\tsetRenderedPaths(paths: SVGPathElement[]) {\r\n\t\tthis.renderedPaths = paths;\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\tsource: this.sourcePort ? this.sourcePort.getParent().getID() : null,\r\n\t\t\tsourcePort: this.sourcePort ? this.sourcePort.getID() : null,\r\n\t\t\ttarget: this.targetPort ? this.targetPort.getParent().getID() : null,\r\n\t\t\ttargetPort: this.targetPort ? this.targetPort.getID() : null,\r\n\t\t\tpoints: _map(this.points, (point) => {\r\n\t\t\t\treturn point.serialize();\r\n\t\t\t}),\r\n\t\t\tlabels: _map(this.labels, (label) => {\r\n\t\t\t\treturn label.serialize();\r\n\t\t\t})\r\n\t\t};\r\n\t}\r\n\r\n\tdoClone(lookupTable = {}, clone) {\r\n\t\tclone.setPoints(\r\n\t\t\t_map(this.getPoints(), (point: PointModel) => {\r\n\t\t\t\treturn point.clone(lookupTable);\r\n\t\t\t})\r\n\t\t);\r\n\t\tif (this.sourcePort) {\r\n\t\t\tclone.setSourcePort(this.sourcePort.clone(lookupTable));\r\n\t\t}\r\n\t\tif (this.targetPort) {\r\n\t\t\tclone.setTargetPort(this.targetPort.clone(lookupTable));\r\n\t\t}\r\n\t}\r\n\r\n\tclearPort(port: PortModel) {\r\n\t\tif (this.sourcePort === port) {\r\n\t\t\tthis.setSourcePort(null);\r\n\t\t} else if (this.targetPort === port) {\r\n\t\t\tthis.setTargetPort(null);\r\n\t\t}\r\n\t}\r\n\r\n\tremove() {\r\n\t\tif (this.sourcePort) {\r\n\t\t\tthis.sourcePort.removeLink(this);\r\n\t\t\tdelete this.sourcePort;\r\n\t\t}\r\n\t\tif (this.targetPort) {\r\n\t\t\tthis.targetPort.removeLink(this);\r\n\t\t\tdelete this.targetPort;\r\n\t\t}\r\n\t\tsuper.remove();\r\n\t}\r\n\r\n\tisLastPoint(point: PointModel) {\r\n\t\tvar index = this.getPointIndex(point);\r\n\t\treturn index === this.points.length - 1;\r\n\t}\r\n\r\n\tgetPointIndex(point: PointModel) {\r\n\t\treturn this.points.indexOf(point);\r\n\t}\r\n\r\n\tgetPointModel(id: string): PointModel | null {\r\n\t\tfor (var i = 0; i < this.points.length; i++) {\r\n\t\t\tif (this.points[i].getID() === id) {\r\n\t\t\t\treturn this.points[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tgetPortForPoint(point: PointModel): PortModel {\r\n\t\tif (this.sourcePort !== null && this.getFirstPoint().getID() === point.getID()) {\r\n\t\t\treturn this.sourcePort;\r\n\t\t}\r\n\t\tif (this.targetPort !== null && this.getLastPoint().getID() === point.getID()) {\r\n\t\t\treturn this.targetPort;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tgetPointForPort(port: PortModel): PointModel {\r\n\t\tif (this.sourcePort !== null && this.sourcePort.getID() === port.getID()) {\r\n\t\t\treturn this.getFirstPoint();\r\n\t\t}\r\n\t\tif (this.targetPort !== null && this.targetPort.getID() === port.getID()) {\r\n\t\t\treturn this.getLastPoint();\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tgetFirstPoint(): PointModel {\r\n\t\treturn this.points[0];\r\n\t}\r\n\r\n\tgetLastPoint(): PointModel {\r\n\t\treturn this.points[this.points.length - 1];\r\n\t}\r\n\r\n\tsetSourcePort(port: PortModel | null) {\r\n\t\tif (port !== null) {\r\n\t\t\tport.addLink(this);\r\n\t\t}\r\n\t\tif (this.sourcePort !== null) {\r\n\t\t\tthis.sourcePort.removeLink(this);\r\n\t\t}\r\n\t\tthis.sourcePort = port;\r\n\t\tthis.fireEvent({ port }, 'sourcePortChanged');\r\n\t\tif (port?.reportedPosition) {\r\n\t\t\tthis.getPointForPort(port).setPosition(port.getCenter());\r\n\t\t}\r\n\t}\r\n\r\n\tgetSourcePort(): PortModel {\r\n\t\treturn this.sourcePort;\r\n\t}\r\n\r\n\tgetTargetPort(): PortModel {\r\n\t\treturn this.targetPort;\r\n\t}\r\n\r\n\tsetTargetPort(port: PortModel | null) {\r\n\t\tif (port !== null) {\r\n\t\t\tport.addLink(this);\r\n\t\t}\r\n\t\tif (this.targetPort !== null) {\r\n\t\t\tthis.targetPort.removeLink(this);\r\n\t\t}\r\n\t\tthis.targetPort = port;\r\n\t\tthis.fireEvent({ port }, 'targetPortChanged');\r\n\t\tif (port?.reportedPosition) {\r\n\t\t\tthis.getPointForPort(port).setPosition(port.getCenter());\r\n\t\t}\r\n\t}\r\n\r\n\tpoint(x: number, y: number, index: number = 1): PointModel {\r\n\t\treturn this.addPoint(this.generatePoint(x, y), index);\r\n\t}\r\n\r\n\taddLabel(label: LabelModel) {\r\n\t\tlabel.setParent(this);\r\n\t\tthis.labels.push(label);\r\n\t}\r\n\r\n\tgetPoints(): PointModel[] {\r\n\t\treturn this.points;\r\n\t}\r\n\r\n\tgetLabels() {\r\n\t\treturn this.labels;\r\n\t}\r\n\r\n\tsetPoints(points: PointModel[]) {\r\n\t\t_forEach(points, (point) => {\r\n\t\t\tpoint.setParent(this);\r\n\t\t});\r\n\t\tthis.points = points;\r\n\t}\r\n\r\n\tremovePoint(pointModel: PointModel) {\r\n\t\tif (this.isLastPoint(pointModel)) this.remove();\r\n\t\tthis.points.splice(this.getPointIndex(pointModel), 1);\r\n\t}\r\n\r\n\tremovePointsBefore(pointModel: PointModel) {\r\n\t\tthis.points.splice(0, this.getPointIndex(pointModel));\r\n\t}\r\n\r\n\tremovePointsAfter(pointModel: PointModel) {\r\n\t\tthis.points.splice(this.getPointIndex(pointModel) + 1);\r\n\t}\r\n\r\n\tremoveMiddlePoints() {\r\n\t\tif (this.points.length > 2) {\r\n\t\t\tthis.points.splice(1, this.points.length - 2);\r\n\t\t}\r\n\t}\r\n\r\n\taddPoint<P extends PointModel>(pointModel: P, index = 1): P {\r\n\t\tpointModel.setParent(this);\r\n\t\tthis.points.splice(index, 0, pointModel);\r\n\t\treturn pointModel;\r\n\t}\r\n\r\n\tgeneratePoint(x: number = 0, y: number = 0): PointModel {\r\n\t\treturn new PointModel({\r\n\t\t\tlink: this,\r\n\t\t\tposition: new Point(x, y)\r\n\t\t});\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { LinkModel } from './LinkModel';\r\nimport { PointModel } from './PointModel';\r\nimport _map from 'lodash/map';\r\nimport { LabelWidget } from '../label/LabelWidget';\r\nimport { BaseEntityEvent, BasePositionModel, ListenerHandle, PeformanceWidget } from '@projectstorm/react-canvas-core';\r\nimport { PortModel } from '../port/PortModel';\r\n\r\nexport interface LinkProps {\r\n\tlink: LinkModel;\r\n\tdiagramEngine: DiagramEngine;\r\n}\r\n\r\nexport interface LinkState {\r\n\tsourcePort: PortModel;\r\n\ttargetPort: PortModel;\r\n}\r\n\r\nexport class LinkWidget extends React.Component<LinkProps, LinkState> {\r\n\tsourceListener: ListenerHandle;\r\n\ttargetListener: ListenerHandle;\r\n\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tsourcePort: null,\r\n\t\t\ttargetPort: null\r\n\t\t};\r\n\t}\r\n\r\n\tcomponentWillUnmount(): void {\r\n\t\tif (this.sourceListener) {\r\n\t\t\tthis.sourceListener.deregister();\r\n\t\t}\r\n\t\tif (this.targetListener) {\r\n\t\t\tthis.targetListener.deregister();\r\n\t\t}\r\n\t}\r\n\r\n\tstatic getDerivedStateFromProps(nextProps: LinkProps, prevState: LinkState): LinkState {\r\n\t\treturn {\r\n\t\t\tsourcePort: nextProps.link.getSourcePort(),\r\n\t\t\ttargetPort: nextProps.link.getTargetPort()\r\n\t\t};\r\n\t}\r\n\r\n\tinstallTarget() {\r\n\t\tthis.targetListener && this.targetListener.deregister();\r\n\r\n\t\tif (!this.props.link.getTargetPort()) return;\r\n\t\tthis.targetListener = this.props.link.getTargetPort().registerListener({\r\n\t\t\treportInitialPosition: (event: BaseEntityEvent<BasePositionModel>) => {\r\n\t\t\t\tthis.forceUpdate();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tinstallSource() {\r\n\t\tthis.sourceListener && this.sourceListener.deregister();\r\n\r\n\t\tif (!this.props.link.getSourcePort()) return;\r\n\t\tthis.sourceListener = this.props.link.getSourcePort().registerListener({\r\n\t\t\treportInitialPosition: (event: BaseEntityEvent<BasePositionModel>) => {\r\n\t\t\t\tthis.forceUpdate();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tcomponentDidUpdate(prevProps: Readonly<LinkProps>, prevState: Readonly<LinkState>, snapshot) {\r\n\t\tif (prevState.sourcePort !== this.state.sourcePort) {\r\n\t\t\tthis.installSource();\r\n\t\t}\r\n\t\tif (prevState.targetPort !== this.state.targetPort) {\r\n\t\t\tthis.installTarget();\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static generateLinePath(firstPoint: PointModel, lastPoint: PointModel): string {\r\n\t\treturn `M${firstPoint.getX()},${firstPoint.getY()} L ${lastPoint.getX()},${lastPoint.getY()}`;\r\n\t}\r\n\r\n\tcomponentDidMount(): void {\r\n\t\tif (this.props.link.getSourcePort()) {\r\n\t\t\tthis.installSource();\r\n\t\t}\r\n\t\tif (this.props.link.getTargetPort()) {\r\n\t\t\tthis.installTarget();\r\n\t\t}\r\n\t}\r\n\r\n\trender() {\r\n\t\tconst { link } = this.props;\r\n\r\n\t\t// only draw the link when we have reported positions\r\n\t\tif (link.getSourcePort() && !link.getSourcePort().reportedPosition) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (link.getTargetPort() && !link.getTargetPort().reportedPosition) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t//generate links\r\n\t\treturn (\r\n\t\t\t<PeformanceWidget model={this.props.link} serialized={this.props.link.serialize()}>\r\n\t\t\t\t{() => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<g data-linkid={this.props.link.getID()}>\r\n\t\t\t\t\t\t\t{this.props.diagramEngine.generateWidgetForLink(link)}\r\n\t\t\t\t\t\t\t{_map(this.props.link.getLabels(), (labelModel, index) => {\r\n\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t<LabelWidget\r\n\t\t\t\t\t\t\t\t\t\tkey={labelModel.getID()}\r\n\t\t\t\t\t\t\t\t\t\tengine={this.props.diagramEngine}\r\n\t\t\t\t\t\t\t\t\t\tlabel={labelModel}\r\n\t\t\t\t\t\t\t\t\t\tindex={index}\r\n\t\t\t\t\t\t\t\t\t/>\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t})}\r\n\t\t\t\t\t\t</g>\r\n\t\t\t\t\t);\r\n\t\t\t\t}}\r\n\t\t\t</PeformanceWidget>\r\n\t\t);\r\n\t}\r\n}\r\n","import { LinkModel } from './LinkModel';\r\nimport {\r\n\tBaseModelListener,\r\n\tBasePositionModel,\r\n\tBasePositionModelGenerics,\r\n\tBasePositionModelOptions\r\n} from '@projectstorm/react-canvas-core';\r\n\r\nexport interface PointModelOptions extends Omit<BasePositionModelOptions, 'type'> {\r\n\tlink: LinkModel;\r\n}\r\n\r\nexport interface PointModelGenerics {\r\n\tPARENT: LinkModel;\r\n\tOPTIONS: PointModelOptions;\r\n\tLISTENER: BaseModelListener;\r\n}\r\n\r\nexport class PointModel<G extends PointModelGenerics = PointModelGenerics> extends BasePositionModel<\r\n\tG & BasePositionModelGenerics\r\n> {\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper({\r\n\t\t\t...options,\r\n\t\t\ttype: 'point'\r\n\t\t});\r\n\t\tthis.parent = options.link;\r\n\t}\r\n\r\n\tisConnectedToPort(): boolean {\r\n\t\treturn this.parent.getPortForPoint(this) !== null;\r\n\t}\r\n\r\n\tgetLink(): LinkModel {\r\n\t\treturn this.getParent();\r\n\t}\r\n\r\n\tremove() {\r\n\t\t//clear references\r\n\t\tif (this.parent) {\r\n\t\t\tthis.parent.removePoint(this);\r\n\t\t}\r\n\t\tsuper.remove();\r\n\t}\r\n\r\n\tisLocked() {\r\n\t\treturn super.isLocked() || this.getParent().isLocked();\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport { AbstractReactFactory, GenerateModelEvent, GenerateWidgetEvent } from '@projectstorm/react-canvas-core';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { NodeLayerModel } from './NodeLayerModel';\r\nimport { NodeLayerWidget } from './NodeLayerWidget';\r\n\r\nexport class NodeLayerFactory extends AbstractReactFactory<NodeLayerModel, DiagramEngine> {\r\n\tconstructor() {\r\n\t\tsuper('diagram-nodes');\r\n\t}\r\n\r\n\tgenerateModel(event: GenerateModelEvent): NodeLayerModel {\r\n\t\treturn new NodeLayerModel();\r\n\t}\r\n\r\n\tgenerateReactWidget(event: GenerateWidgetEvent<NodeLayerModel>): JSX.Element {\r\n\t\treturn <NodeLayerWidget layer={event.model} engine={this.engine} />;\r\n\t}\r\n}\r\n","import { LayerModel, LayerModelGenerics } from '@projectstorm/react-canvas-core';\r\nimport { NodeModel } from '../node/NodeModel';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { DiagramModel } from '../../models/DiagramModel';\r\n\r\nexport interface NodeLayerModelGenerics extends LayerModelGenerics {\r\n\tCHILDREN: NodeModel;\r\n\tENGINE: DiagramEngine;\r\n}\r\n\r\nexport class NodeLayerModel<G extends NodeLayerModelGenerics = NodeLayerModelGenerics> extends LayerModel<G> {\r\n\tconstructor( ) {\r\n\t\tsuper({\r\n\t\t\ttype: 'diagram-nodes',\r\n\t\t\tisSvg: false,\r\n\t\t\ttransformed: true,\r\n\t\t\tisWorktable : false\r\n\t\t});\r\n\t}\r\n\r\n\taddModel(model: G['CHILDREN']): void {\r\n\t\tif (!(model instanceof NodeModel)) {\r\n\t\t\tthrow new Error('Can only add nodes to this layer');\r\n\t\t}\r\n\t\tmodel.registerListener({\r\n\t\t\tentityRemoved: () => {\r\n\t\t\t\t(this.getParent() as DiagramModel).removeNode(model);\r\n\t\t\t}\r\n\t\t});\r\n\t\tsuper.addModel(model);\r\n\t}\r\n\r\n\tgetChildModelFactoryBank(engine: G['ENGINE']) {\r\n\t\treturn engine.getNodeFactories();\r\n\t}\r\n\r\n\tgetNodes() {\r\n\t\treturn this.getModels();\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport _map from 'lodash/map';\r\nimport { NodeModel } from '../node/NodeModel';\r\nimport { NodeWidget } from '../node/NodeWidget';\r\nimport { NodeLayerModel } from './NodeLayerModel';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\n\r\nexport interface NodeLayerWidgetProps {\r\n\tlayer: NodeLayerModel;\r\n\tengine: DiagramEngine;\r\n}\r\n\r\nexport class NodeLayerWidget extends React.Component<NodeLayerWidgetProps> {\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<>\r\n\t\t\t\t{_map(this.props.layer.getNodes(), (node: NodeModel) => {\r\n\t\t\t\t\tif(node.isWorktable && this.props.layer.isWorktable){\r\n\t\t\t\t\t\treturn <NodeWidget key={node.getID()} diagramEngine={this.props.engine} node={node} />;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\treturn <NodeWidget key={node.getID()} diagramEngine={this.props.engine} node={node} />;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t})}\r\n\t\t\t</>\r\n\t\t);\r\n\t}\r\n}\r\n","import _forEach from 'lodash/forEach';\r\nimport _map from 'lodash/map';\r\nimport _values from 'lodash/values';\r\nimport { DiagramModel } from '../../models/DiagramModel';\r\nimport { PortModel } from '../port/PortModel';\r\nimport { LinkModel } from '../link/LinkModel';\r\nimport { Point, Rectangle } from '@projectstorm/geometry';\r\nimport {\r\n\tBaseEntityEvent,\r\n\tBaseModelListener,\r\n\tBasePositionModel,\r\n\tBasePositionModelGenerics,\r\n\tDeserializeEvent\r\n} from '@projectstorm/react-canvas-core';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\n\r\nexport interface NodeModelListener extends BaseModelListener {\r\n\tpositionChanged?(event: BaseEntityEvent<NodeModel>): void;\r\n}\r\n\r\nexport interface NodeModelGenerics extends BasePositionModelGenerics {\r\n\tLISTENER: NodeModelListener;\r\n\tPARENT: DiagramModel;\r\n}\r\n\r\nexport class NodeModel<G extends NodeModelGenerics = NodeModelGenerics> extends BasePositionModel<G> {\r\n\tprotected ports: { [s: string]: PortModel };\r\n\r\n\t// calculated post rendering so routing can be done correctly\r\n\twidth: number;\r\n\theight: number;\r\n\tisWorktable: boolean;\r\n\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper(options);\r\n\t\tthis.ports = {};\r\n\t\tthis.width = 0;\r\n\t\tthis.height = 0;\r\n\t\tthis.isWorktable = false;\r\n\t}\r\n\r\n\tgetBoundingBox(): Rectangle {\r\n\t\treturn Rectangle.fromPointAndSize(this.getPosition(), this.width, this.height);\r\n\t}\r\n\r\n\tgetIsWorktable(): boolean {\r\n\t\treturn this.isWorktable;\r\n\t}\r\n\tsetIsWorktable(value: boolean ): void {\r\n\t\t this.isWorktable = value;\r\n\t}\r\n\r\n\tsetPosition(point: Point): void;\r\n\tsetPosition(x: number, y: number): void;\r\n\tsetPosition(x: number | Point, y?: number): void {\r\n\t\tconst old = this.position;\r\n\r\n\t\tif (x instanceof Point) {\r\n\t\t\tsuper.setPosition(x);\r\n\t\t} else {\r\n\t\t\tsuper.setPosition(x, y);\r\n\t\t}\r\n\r\n\t\t//also update the port co-ordinates (for make glorious speed)\r\n\t\t_forEach(this.ports, (port) => {\r\n\t\t\tport.setPosition(port.getX() + this.position.x - old.x, port.getY() + this.position.y - old.y);\r\n\t\t});\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\r\n\t\t//deserialize ports\r\n\t\t_forEach(event.data.ports, (port: any) => {\r\n\t\t\tlet portOb = (event.engine as DiagramEngine).getFactoryForPort(port.type).generateModel({});\r\n\t\t\tportOb.deserialize({\r\n\t\t\t\t...event,\r\n\t\t\t\tdata: port\r\n\t\t\t});\r\n\t\t\t// the links need these\r\n\t\t\tevent.registerModel(portOb);\r\n\t\t\tthis.addPort(portOb);\r\n\t\t});\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\tports: _map(this.ports, (port) => {\r\n\t\t\t\treturn port.serialize();\r\n\t\t\t})\r\n\t\t};\r\n\t}\r\n\r\n\tdoClone(lookupTable = {}, clone) {\r\n\t\t// also clone the ports\r\n\t\tclone.ports = {};\r\n\t\t_forEach(this.ports, (port) => {\r\n\t\t\tclone.addPort(port.clone(lookupTable));\r\n\t\t});\r\n\t}\r\n\r\n\tremove() {\r\n\t\tsuper.remove();\r\n\t\t_forEach(this.ports, (port) => {\r\n\t\t\t_forEach(port.getLinks(), (link) => {\r\n\t\t\t\tlink.remove();\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tgetPortFromID(id): PortModel | null {\r\n\t\tfor (var i in this.ports) {\r\n\t\t\tif (this.ports[i].getID() === id) {\r\n\t\t\t\treturn this.ports[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tgetLink(id: string): LinkModel {\r\n\t\tfor (let portID in this.ports) {\r\n\t\t\tconst links = this.ports[portID].getLinks();\r\n\t\t\tif (links[id]) {\r\n\t\t\t\treturn links[id];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgetPort(name: string): PortModel | null {\r\n\t\treturn this.ports[name];\r\n\t}\r\n\r\n\tgetPorts(): { [s: string]: PortModel } {\r\n\t\treturn this.ports;\r\n\t}\r\n\r\n\tremovePort(port: PortModel) {\r\n\t\t// clear the port from the links\r\n\t\tfor (let link of _values(port.getLinks())) {\r\n\t\t\tlink.clearPort(port);\r\n\t\t}\r\n\t\t//clear the parent node reference\r\n\t\tif (this.ports[port.getName()]) {\r\n\t\t\tthis.ports[port.getName()].setParent(null);\r\n\t\t\tdelete this.ports[port.getName()];\r\n\t\t}\r\n\t}\r\n\r\n\taddPort(port: PortModel): PortModel {\r\n\t\tport.setParent(this);\r\n\t\tthis.ports[port.getName()] = port;\r\n\t\treturn port;\r\n\t}\r\n\r\n\tupdateDimensions({ width, height }: { width: number; height: number }) {\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport _forEach from 'lodash/forEach';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { NodeModel } from './NodeModel';\r\nimport { BaseEntityEvent, BaseModel, ListenerHandle, PeformanceWidget } from '@projectstorm/react-canvas-core';\r\nimport styled from '@emotion/styled';\r\nimport ResizeObserver from 'resize-observer-polyfill';\r\n\r\nexport interface NodeProps {\r\n\tnode: NodeModel;\r\n\tchildren?: any;\r\n\tdiagramEngine: DiagramEngine;\r\n}\r\n\r\nnamespace S {\r\n\texport const Node = styled.div`\r\n\t\tposition: absolute;\r\n\t\t-webkit-touch-callout: none; /* iOS Safari */\r\n\t\t-webkit-user-select: none; /* Chrome/Safari/Opera */\r\n\t\tuser-select: none;\r\n\t\tcursor: move;\r\n\t\tpointer-events: all;\r\n\t`;\r\n}\r\n\r\nexport class NodeWidget extends React.Component<NodeProps> {\r\n\tob: any;\r\n\tref: React.RefObject<HTMLDivElement>;\r\n\tlistener: ListenerHandle;\r\n\r\n\tconstructor(props: NodeProps) {\r\n\t\tsuper(props);\r\n\t\tthis.ref = React.createRef();\r\n\t}\r\n\r\n\tcomponentWillUnmount(): void {\r\n\t\tthis.ob.disconnect();\r\n\t\tthis.ob = null;\r\n\r\n\t\tthis.listener?.deregister();\r\n\t\tthis.listener = null;\r\n\t}\r\n\r\n\tcomponentDidUpdate(prevProps: Readonly<NodeProps>, prevState: Readonly<any>, snapshot?: any): void {\r\n\t\tif (this.listener && this.props.node !== prevProps.node) {\r\n\t\t\tthis.listener.deregister();\r\n\t\t\tthis.installSelectionListener();\r\n\t\t}\r\n\t}\r\n\r\n\tinstallSelectionListener() {\r\n\t\tthis.listener = this.props.node.registerListener({\r\n\t\t\tselectionChanged: (event: BaseEntityEvent<BaseModel> & { isSelected: boolean }) => {\r\n\t\t\t\tthis.forceUpdate();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tupdateSize(width: number, height: number) {\r\n\t\tthis.props.node.updateDimensions({ width, height });\r\n\r\n\t\t//now mark the links as dirty\r\n\t\ttry {\r\n\t\t\t_forEach(this.props.node.getPorts(), (port) => {\r\n\t\t\t\tport.updateCoords(this.props.diagramEngine.getPortCoords(port));\r\n\t\t\t});\r\n\t\t} catch (ex) {}\r\n\t}\r\n\r\n\tcomponentDidMount(): void {\r\n\t\t// @ts-ignore\r\n\t\tthis.ob = new ResizeObserver((entities) => {\r\n\t\t\tconst bounds = entities[0].contentRect;\r\n\t\t\tthis.updateSize(bounds.width, bounds.height);\r\n\t\t});\r\n\r\n\t\tconst b = this.ref.current.getBoundingClientRect();\r\n\t\tthis.updateSize(b.width, b.height);\r\n\t\tthis.ob.observe(this.ref.current);\r\n\t\tthis.installSelectionListener();\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<PeformanceWidget model={this.props.node} serialized={this.props.node.serialize()}>\r\n\t\t\t\t{() => {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\t<S.Node\r\n\t\t\t\t\t\t\tclassName=\"node\"\r\n\t\t\t\t\t\t\tref={this.ref}\r\n\t\t\t\t\t\t\tdata-nodeid={this.props.node.getID()}\r\n\t\t\t\t\t\t\tstyle={{\r\n\t\t\t\t\t\t\t\ttop: this.props.node.getY(),\r\n\t\t\t\t\t\t\t\tleft: this.props.node.getX()\r\n\t\t\t\t\t\t\t}}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t{this.props.diagramEngine.generateWidgetForNode(this.props.node)}\r\n\t\t\t\t\t\t</S.Node>\r\n\t\t\t\t\t);\r\n\t\t\t\t}}\r\n\t\t\t</PeformanceWidget>\r\n\t\t);\r\n\t}\r\n}\r\n","import { NodeModel } from '../node/NodeModel';\r\nimport { LinkModel } from '../link/LinkModel';\r\nimport _forEach from 'lodash/forEach';\r\nimport _isFinite from 'lodash/isFinite';\r\nimport _map from 'lodash/map';\r\nimport _size from 'lodash/size';\r\nimport _values from 'lodash/values';\r\nimport { Point, Rectangle } from '@projectstorm/geometry';\r\nimport {\r\n\tBaseEntityEvent,\r\n\tBaseModelOptions,\r\n\tBasePositionModel,\r\n\tBasePositionModelGenerics,\r\n\tBasePositionModelListener,\r\n\tDeserializeEvent\r\n} from '@projectstorm/react-canvas-core';\r\n\r\nexport enum PortModelAlignment {\r\n\tTOP = 'top',\r\n\tLEFT = 'left',\r\n\tBOTTOM = 'bottom',\r\n\tRIGHT = 'right'\r\n}\r\n\r\nexport interface PortModelListener extends BasePositionModelListener {\r\n\t/**\r\n\t * fires when it first receives positional information\r\n\t */\r\n\treportInitialPosition?: (event: BaseEntityEvent<PortModel>) => void;\r\n}\r\n\r\nexport interface PortModelOptions extends BaseModelOptions {\r\n\talignment?: PortModelAlignment;\r\n\tmaximumLinks?: number;\r\n\tname: string;\r\n}\r\n\r\nexport interface PortModelGenerics extends BasePositionModelGenerics {\r\n\tOPTIONS: PortModelOptions;\r\n\tPARENT: NodeModel;\r\n\tLISTENER: PortModelListener;\r\n}\r\n\r\nexport class PortModel<G extends PortModelGenerics = PortModelGenerics> extends BasePositionModel<G> {\r\n\tlinks: { [id: string]: LinkModel };\r\n\r\n\t// calculated post rendering so routing can be done correctly\r\n\twidth: number;\r\n\theight: number;\r\n\treportedPosition: boolean;\r\n\r\n\tconstructor(options: G['OPTIONS']) {\r\n\t\tsuper(options);\r\n\t\tthis.links = {};\r\n\t\tthis.reportedPosition = false;\r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tsuper.deserialize(event);\r\n\t\tthis.reportedPosition = false;\r\n\t\tthis.options.name = event.data.name;\r\n\t\tthis.options.alignment = event.data.alignment;\r\n\t}\r\n\r\n\tserialize() {\r\n\t\treturn {\r\n\t\t\t...super.serialize(),\r\n\t\t\tname: this.options.name,\r\n\t\t\talignment: this.options.alignment,\r\n\t\t\tparentNode: this.parent.getID(),\r\n\t\t\tlinks: _map(this.links, (link) => {\r\n\t\t\t\treturn link.getID();\r\n\t\t\t})\r\n\t\t};\r\n\t}\r\n\r\n\tsetPosition(point: Point);\r\n\tsetPosition(x: number, y: number);\r\n\tsetPosition(x, y?) {\r\n\t\tlet old = this.position;\r\n\t\tsuper.setPosition(x, y);\r\n\t\t_forEach(this.getLinks(), (link) => {\r\n\t\t\tlet point = link.getPointForPort(this);\r\n\t\t\tpoint.setPosition(point.getX() + x - old.x, point.getY() + y - old.y);\r\n\t\t});\r\n\t}\r\n\r\n\tdoClone(lookupTable = {}, clone: PortModel) {\r\n\t\tclone.links = {};\r\n\t\tclone.parent = this.getParent().clone(lookupTable);\r\n\t}\r\n\r\n\tgetNode(): NodeModel {\r\n\t\treturn this.getParent();\r\n\t}\r\n\r\n\tgetName(): string {\r\n\t\treturn this.options.name;\r\n\t}\r\n\r\n\tgetMaximumLinks(): number {\r\n\t\treturn this.options.maximumLinks;\r\n\t}\r\n\r\n\tsetMaximumLinks(maximumLinks: number) {\r\n\t\tthis.options.maximumLinks = maximumLinks;\r\n\t}\r\n\r\n\tremoveLink(link: LinkModel) {\r\n\t\tdelete this.links[link.getID()];\r\n\t}\r\n\r\n\taddLink(link: LinkModel) {\r\n\t\tthis.links[link.getID()] = link;\r\n\t}\r\n\r\n\tgetLinks(): { [id: string]: LinkModel } {\r\n\t\treturn this.links;\r\n\t}\r\n\r\n\tpublic createLinkModel(): LinkModel | null {\r\n\t\tif (_isFinite(this.options.maximumLinks)) {\r\n\t\t\tvar numberOfLinks: number = _size(this.links);\r\n\t\t\tif (this.options.maximumLinks === 1 && numberOfLinks >= 1) {\r\n\t\t\t\treturn _values(this.links)[0];\r\n\t\t\t} else if (numberOfLinks >= this.options.maximumLinks) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\treportPosition() {\r\n\t\t_forEach(this.getLinks(), (link) => {\r\n\t\t\tlink.getPointForPort(this).setPosition(this.getCenter());\r\n\t\t});\r\n\t\tthis.fireEvent(\r\n\t\t\t{\r\n\t\t\t\tentity: this\r\n\t\t\t},\r\n\t\t\t'reportInitialPosition'\r\n\t\t);\r\n\t}\r\n\r\n\tgetCenter(): Point {\r\n\t\treturn new Point(this.getX() + this.width / 2, this.getY() + this.height / 2);\r\n\t}\r\n\r\n\tgetBoundingBox(): Rectangle {\r\n\t\treturn Rectangle.fromPointAndSize(this.position, this.width, this.height);\r\n\t}\r\n\r\n\tupdateCoords(coords: Rectangle) {\r\n\t\tthis.width = coords.getWidth();\r\n\t\tthis.height = coords.getHeight();\r\n\t\tthis.setPosition(coords.getTopLeft());\r\n\t\tthis.reportedPosition = true;\r\n\t\tthis.reportPosition();\r\n\t}\r\n\r\n\tcanLinkToPort(port: PortModel): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tisLocked() {\r\n\t\treturn super.isLocked() || this.getParent().isLocked();\r\n\t}\r\n}\r\n","import * as React from 'react';\r\nimport _keys from 'lodash/keys';\r\nimport { PortModel } from './PortModel';\r\nimport { DiagramEngine } from '../../DiagramEngine';\r\nimport { ListenerHandle, Toolkit } from '@projectstorm/react-canvas-core';\r\n\r\nexport interface PortProps {\r\n\tport: PortModel;\r\n\tengine: DiagramEngine;\r\n\tclassName?;\r\n\tstyle?;\r\n}\r\n\r\nexport class PortWidget extends React.Component<React.PropsWithChildren<PortProps>> {\r\n\tref: React.RefObject<HTMLDivElement>;\r\n\tengineListenerHandle: ListenerHandle;\r\n\r\n\tconstructor(props: PortProps) {\r\n\t\tsuper(props);\r\n\t\tthis.ref = React.createRef();\r\n\t}\r\n\r\n\treport() {\r\n\t\tthis.props.port.updateCoords(this.props.engine.getPortCoords(this.props.port, this.ref.current));\r\n\t}\r\n\r\n\tcomponentWillUnmount(): void {\r\n\t\tthis.engineListenerHandle && this.engineListenerHandle.deregister();\r\n\t}\r\n\r\n\tcomponentDidUpdate(prevProps: Readonly<PortProps>, prevState, snapshot?: any): void {\r\n\t\tif (!this.props.port.reportedPosition) {\r\n\t\t\tthis.report();\r\n\t\t}\r\n\t}\r\n\r\n\tcomponentDidMount(): void {\r\n\t\tthis.engineListenerHandle = this.props.engine.registerListener({\r\n\t\t\tcanvasReady: () => {\r\n\t\t\t\tthis.report();\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (this.props.engine.getCanvas()) {\r\n\t\t\tthis.report();\r\n\t\t}\r\n\t}\r\n\r\n\tgetExtraProps() {\r\n\t\tif (Toolkit.TESTING) {\r\n\t\t\tconst links = _keys(this.props.port.getNode().getPort(this.props.port.getName()).links).join(',');\r\n\t\t\treturn {\r\n\t\t\t\t'data-links': links\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn {};\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tstyle={this.props.style}\r\n\t\t\t\tref={this.ref}\r\n\t\t\t\tclassName={`port ${this.props.className || ''}`}\r\n\t\t\t\tdata-name={this.props.port.getName()}\r\n\t\t\t\tdata-nodeid={this.props.port.getNode().getID()}\r\n\t\t\t\t{...this.getExtraProps()}\r\n\t\t\t>\r\n\t\t\t\t{this.props.children}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n","import _filter from 'lodash/filter';\r\nimport _flatMap from 'lodash/flatMap';\r\nimport _forEach from 'lodash/forEach';\r\nimport _some from 'lodash/some';\r\nimport _values from 'lodash/values';\r\nimport { LinkModel } from '../entities/link/LinkModel';\r\nimport { NodeModel } from '../entities/node/NodeModel';\r\nimport {\r\n\tBaseEntityEvent,\r\n\tBaseEntityListener,\r\n\tBaseModel,\r\n\tCanvasModel,\r\n\tCanvasModelGenerics,\r\n\tLayerModel,\r\n\tDeserializeEvent\r\n} from '@projectstorm/react-canvas-core';\r\nimport { NodeLayerModel } from '../entities/node-layer/NodeLayerModel';\r\nimport { LinkLayerModel } from '../entities/link-layer/LinkLayerModel';\r\n\r\nexport interface DiagramListener extends BaseEntityListener {\r\n\tnodesUpdated?(event: BaseEntityEvent & { node: NodeModel; isCreated: boolean }): void;\r\n\r\n\tlinksUpdated?(event: BaseEntityEvent & { link: LinkModel; isCreated: boolean }): void;\r\n}\r\n\r\nexport interface DiagramModelGenerics extends CanvasModelGenerics {\r\n\tLISTENER: DiagramListener;\r\n}\r\n\r\nexport class DiagramModel<G extends DiagramModelGenerics = DiagramModelGenerics> extends CanvasModel<G> {\r\n\tprotected activeNodeLayer: NodeLayerModel;\r\n\tprotected activeLinkLayer: LinkLayerModel;\r\n\r\n\tconstructor(options: G['OPTIONS'] = {}) {\r\n\t\tsuper(options);\r\n\t\tthis.addLayer(new NodeLayerModel());\r\n\t\tthis.addLayer(new LinkLayerModel());\r\n \r\n\t}\r\n\r\n\tdeserialize(event: DeserializeEvent<this>) {\r\n\t\tthis.layers = [];\r\n\t\tsuper.deserialize(event);\r\n\t}\r\n\r\n\taddLayer(layer: LayerModel): void {\r\n\t\tsuper.addLayer(layer);\r\n\t\tif (layer instanceof NodeLayerModel) {\r\n\t\t\tthis.activeNodeLayer = layer;\r\n\t\t}\r\n\t\tif (layer instanceof LinkLayerModel) {\r\n\t\t\tthis.activeLinkLayer = layer;\r\n\t\t}\r\n\t}\r\n\r\n\tgetLinkLayers(): LinkLayerModel[] {\r\n\t\treturn _filter(this.layers, (layer) => {\r\n\t\t\treturn layer instanceof LinkLayerModel;\r\n\t\t}) as LinkLayerModel[];\r\n\t}\r\n\r\n\tgetNodeLayers(): NodeLayerModel[] {\r\n\t\treturn _filter(this.layers, (layer) => {\r\n\t\t\treturn layer instanceof NodeLayerModel;\r\n\t\t}) as NodeLayerModel[];\r\n\t}\r\n\r\n\tgetActiveNodeLayer(): NodeLayerModel {\r\n\t\tif (!this.activeNodeLayer) {\r\n\t\t\tconst layers = this.getNodeLayers();\r\n\t\t\tif (layers.length === 0) {\r\n\t\t\t\tthis.addLayer(new NodeLayerModel());\r\n\t\t\t} else {\r\n\t\t\t\tthis.activeNodeLayer = layers[0];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.activeNodeLayer;\r\n\t}\r\n\r\n\tgetActiveLinkLayer(): LinkLayerModel {\r\n\t\tif (!this.activeLinkLayer) {\r\n\t\t\tconst layers = this.getLinkLayers();\r\n\t\t\tif (layers.length === 0) {\r\n\t\t\t\tthis.addLayer(new LinkLayerModel());\r\n\t\t\t} else {\r\n\t\t\t\tthis.activeLinkLayer = layers[0];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.activeLinkLayer;\r\n\t}\r\n\r\n\tgetNode(node: string): NodeModel {\r\n\t\tfor (const layer of this.getNodeLayers()) {\r\n\t\t\tconst model = layer.getModel(node);\r\n\t\t\tif (model) {\r\n\t\t\t\treturn model;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgetLink(link: string): LinkModel {\r\n\t\tfor (const layer of this.getLinkLayers()) {\r\n\t\t\tconst model = layer.getModel(link);\r\n\t\t\tif (model) {\r\n\t\t\t\treturn model;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\taddAll(...models: BaseModel[]): BaseModel[] {\r\n\t\t_forEach(models, (model) => {\r\n\t\t\tif (model instanceof LinkModel) {\r\n\t\t\t\tthis.addLink(model);\r\n\t\t\t} else if (model instanceof NodeModel) {\r\n\t\t\t\tthis.addNode(model);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn models;\r\n\t}\r\n\r\n\taddLink(link: LinkModel): LinkModel {\r\n\t\tthis.getActiveLinkLayer().addModel(link);\r\n\t\tthis.fireEvent(\r\n\t\t\t{\r\n\t\t\t\tlink,\r\n\t\t\t\tisCreated: true\r\n\t\t\t},\r\n\t\t\t'linksUpdated'\r\n\t\t);\r\n\t\treturn link;\r\n\t}\r\n\r\n\taddNode(node: NodeModel): NodeModel {\r\n\t\tthis.getActiveNodeLayer().addModel(node);\r\n\t\tthis.fireEvent({ node, isCreated: true }, 'nodesUpdated');\r\n\t\treturn node;\r\n\t}\r\n\r\n\tremoveLink(link: LinkModel) {\r\n\t\tconst removed = _some(this.getLinkLayers(), (layer) => {\r\n\t\t\treturn layer.removeModel(link);\r\n\t\t});\r\n\t\tif (removed) {\r\n\t\t\tthis.fireEvent({ link, isCreated: false }, 'linksUpdated');\r\n\t\t}\r\n\t}\r\n\r\n\tremoveNode(node: NodeModel) {\r\n\t\tconst removed = _some(this.getNodeLayers(), (layer) => {\r\n\t\t\treturn layer.removeModel(node);\r\n\t\t});\r\n\t\tif (removed) {\r\n\t\t\tthis.fireEvent({ node, isCreated: false }, 'nodesUpdated');\r\n\t\t}\r\n\t}\r\n\r\n\tgetLinks(): LinkModel[] {\r\n\t\treturn _flatMap(this.getLinkLayers(), (layer) => {\r\n\t\t\treturn _values(layer.getModels());\r\n\t\t});\r\n\t}\r\n\r\n\tgetNodes(): NodeModel[] {\r\n\t\treturn _flatMap(this.getNodeLayers(), (layer) => {\r\n\t\t\treturn _values(layer.getModels());\r\n\t\t});\r\n\t}\r\n}\r\n","import { MouseEvent, TouchEvent } from 'react';\r\nimport {\r\n\tSelectingState,\r\n\tState,\r\n\tAction,\r\n\tInputType,\r\n\tActionEvent,\r\n\tDragCanvasState\r\n} from '@projectstorm/react-canvas-core';\r\nimport { PortModel } from '../entities/port/PortModel';\r\nimport { DragNewLinkState } from './DragNewLinkState';\r\nimport { DiagramEngine } from '../DiagramEngine';\r\nimport { DragDiagramItemsState } from './DragDiagramItemsState';\r\n\r\nexport class DefaultDiagramState extends State<DiagramEngine> {\r\n\tdragCanvas: DragCanvasState;\r\n\tdragNewLink: DragNewLinkState;\r\n\tdragItems: DragDiagramItemsState;\r\n\r\n\tconstructor() {\r\n\t\tsuper({\r\n\t\t\tname: 'default-diagrams'\r\n\t\t});\r\n\t\tthis.childStates = [new SelectingState()];\r\n\t\tthis.dragCanvas = new DragCanvasState();\r\n\t\tthis.dragNewLink = new DragNewLinkState();\r\n\t\tthis.dragItems = new DragDiagramItemsState();\r\n\r\n\t\t// determine what was clicked on\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_DOWN,\r\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\r\n\t\t\t\t\tconst element = this.engine.getActionEventBus().getModelForEvent(event);\r\n\r\n\t\t\t\t\t// the canvas was clicked on, transition to the dragging canvas state\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\tthis.transitionWithEvent(this.dragCanvas, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// initiate dragging a new link\r\n\t\t\t\t\telse if (element instanceof PortModel) {\r\n\t\t\t\t\t\tthis.transitionWithEvent(this.dragNewLink, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// move the items (and potentially link points)\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.transitionWithEvent(this.dragItems, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\t// touch drags the canvas\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.TOUCH_START,\r\n\t\t\t\tfire: (event: ActionEvent<TouchEvent>) => {\r\n\t\t\t\t\tthis.transitionWithEvent(this.dragCanvas, event);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n","import { Action, ActionEvent, InputType, MoveItemsState } from '@projectstorm/react-canvas-core';\r\nimport _forEach from 'lodash/forEach';\r\nimport { PointModel } from '../entities/link/PointModel';\r\nimport { DiagramEngine } from '../DiagramEngine';\r\nimport { PortModel } from '../entities/port/PortModel';\r\nimport { MouseEvent } from 'react';\r\nimport { LinkModel } from '../entities/link/LinkModel';\r\n\r\nexport class DragDiagramItemsState<E extends DiagramEngine = DiagramEngine> extends MoveItemsState<E> {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_UP,\r\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\r\n\t\t\t\t\tconst item = this.engine.getMouseElement(event.event);\r\n\t\t\t\t\tif (item instanceof PortModel) {\r\n\t\t\t\t\t\t_forEach(this.initialPositions, (position) => {\r\n\t\t\t\t\t\t\tif (position.item instanceof PointModel) {\r\n\t\t\t\t\t\t\t\tconst link = position.item.getParent() as LinkModel;\r\n\r\n\t\t\t\t\t\t\t\t// only care about the last links\r\n\t\t\t\t\t\t\t\tif (link.getLastPoint() !== position.item) {\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (link.getSourcePort().canLinkToPort(item)) {\r\n\t\t\t\t\t\t\t\t\tlink.setTargetPort(item);\r\n\t\t\t\t\t\t\t\t\titem.reportPosition();\r\n\t\t\t\t\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n}\r\n","import {\r\n\tAbstractDisplacementState,\r\n\tAbstractDisplacementStateEvent,\r\n\tAction,\r\n\tActionEvent,\r\n\tInputType\r\n} from '@projectstorm/react-canvas-core';\r\nimport { PortModel } from '../entities/port/PortModel';\r\nimport { MouseEvent } from 'react';\r\nimport { LinkModel } from '../entities/link/LinkModel';\r\nimport { DiagramEngine } from '../DiagramEngine';\r\n\r\nexport interface DragNewLinkStateOptions {\r\n\t/**\r\n\t * If enabled, the links will stay on the canvas if they dont connect to a port\r\n\t * when dragging finishes\r\n\t */\r\n\tallowLooseLinks?: boolean;\r\n\t/**\r\n\t * If enabled, then a link can still be drawn from the port even if it is locked\r\n\t */\r\n\tallowLinksFromLockedPorts?: boolean;\r\n}\r\n\r\nexport class DragNewLinkState<E extends DiagramEngine = DiagramEngine> extends AbstractDisplacementState<E> {\r\n\tport: PortModel;\r\n\tlink: LinkModel;\r\n\tconfig: DragNewLinkStateOptions;\r\n\r\n\tconstructor(options: DragNewLinkStateOptions = {}) {\r\n\t\tsuper({ name: 'drag-new-link' });\r\n\r\n\t\tthis.config = {\r\n\t\t\tallowLooseLinks: true,\r\n\t\t\tallowLinksFromLockedPorts: false,\r\n\t\t\t...options\r\n\t\t};\r\n\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_DOWN,\r\n\t\t\t\tfire: (event: ActionEvent<MouseEvent, PortModel>) => {\r\n\t\t\t\t\tthis.port = this.engine.getMouseElement(event.event) as PortModel;\r\n\t\t\t\t\tif (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\r\n\t\t\t\t\t\tthis.eject();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.link = this.port.createLinkModel();\r\n\r\n\t\t\t\t\t// if no link is given, just eject the state\r\n\t\t\t\t\tif (!this.link) {\r\n\t\t\t\t\t\tthis.eject();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.link.setSelected(true);\r\n\t\t\t\t\tthis.link.setSourcePort(this.port);\r\n\t\t\t\t\tthis.engine.getModel().addLink(this.link);\r\n\t\t\t\t\tthis.port.reportPosition();\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\tthis.registerAction(\r\n\t\t\tnew Action({\r\n\t\t\t\ttype: InputType.MOUSE_UP,\r\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\r\n\t\t\t\t\tconst model = this.engine.getMouseElement(event.event);\r\n\t\t\t\t\t// check to see if we connected to a new port\r\n\t\t\t\t\tif (model instanceof PortModel) {\r\n\t\t\t\t\t\tif (this.port.canLinkToPort(model)) {\r\n\t\t\t\t\t\t\tthis.link.setTargetPort(model);\r\n\t\t\t\t\t\t\tmodel.reportPosition();\r\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.link.remove();\r\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!this.config.allowLooseLinks) {\r\n\t\t\t\t\t\tthis.link.remove();\r\n\t\t\t\t\t\tthis.engine.repaintCanvas();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the link's far-end point position on mouse move.\r\n\t * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\r\n\t * as the possible engine offset\r\n\t */\r\n\tfireMouseMoved(event: AbstractDisplacementStateEvent): any {\r\n\t\tconst portPos = this.port.getPosition();\r\n\t\tconst zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\r\n\t\tconst engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\r\n\t\tconst engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\r\n\t\tconst initialXRelative = this.initialXRelative / zoomLevelPercentage;\r\n\t\tconst initialYRelative = this.initialYRelative / zoomLevelPercentage;\r\n\t\tconst linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\r\n\t\tconst linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\r\n\r\n\t\tthis.link.getLastPoint().setPosition(linkNextX, linkNextY);\r\n\t\tthis.engine.repaintCanvas();\r\n\t}\r\n}\r\n","module.exports = require(\"@emotion/styled\");","module.exports = require(\"@projectstorm/geometry\");","module.exports = require(\"@projectstorm/react-canvas-core\");","module.exports = require(\"lodash/filter\");","module.exports = require(\"lodash/flatMap\");","module.exports = require(\"lodash/forEach\");","module.exports = require(\"lodash/isFinite\");","module.exports = require(\"lodash/keys\");","module.exports = require(\"lodash/map\");","module.exports = require(\"lodash/size\");","module.exports = require(\"lodash/slice\");","module.exports = require(\"lodash/some\");","module.exports = require(\"lodash/values\");","module.exports = require(\"react\");","module.exports = require(\"resize-observer-polyfill\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export * from './models/DiagramModel';\r\nexport * from './entities/label/LabelModel';\r\n\r\nexport * from './entities/link/LinkModel';\r\nexport * from './entities/link/PointModel';\r\nexport * from './entities/link/LinkWidget';\r\n\r\nexport * from './entities/link-layer/LinkLayerModel';\r\nexport * from './entities/link-layer/LinkLayerWidget';\r\nexport * from './entities/link-layer/LinkLayerFactory';\r\n\r\nexport * from './entities/node-layer/NodeLayerModel';\r\nexport * from './entities/node-layer/NodeLayerWidget';\r\nexport * from './entities/node-layer/NodeLayerFactory';\r\n\r\nexport * from './entities/node/NodeModel';\r\nexport * from './entities/node/NodeWidget';\r\nexport * from './entities/port/PortModel';\r\nexport * from './entities/port/PortWidget';\r\n\r\nexport * from './states/DefaultDiagramState';\r\nexport * from './states/DragDiagramItemsState';\r\nexport * from './states/DragNewLinkState';\r\n\r\nexport * from './DiagramEngine';\r\n"],"names":[],"sourceRoot":""}